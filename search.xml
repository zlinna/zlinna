<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Go 的位运算</title>
      <link href="/2019/09/07/go%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2019/09/07/go%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2><span id="go-的位运算">Go 的位运算</span></h2><p>在 Go 语言中支持以下几种操作位的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 Go 语言中支持以下几种操作位的方式：</span></span><br><span class="line"><span class="comment">        &amp;   // 位与：仅当 a 和 b 都为 1 时，操作 a&amp;b 返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment">        |   // 位或：仅当 a 和 b 都为 0 时，操作 a|b 返回 0，否则返回 1。</span></span><br><span class="line"><span class="comment">        ^   // 异或：仅当 a!=b 时，操作 a^b 返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment">        &amp;^  // 位与非：仅当 a=1, b=0 时，操作 a&amp;^b 返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment">        &lt;&lt;  // 左移：a &lt;&lt; n，将 a 中的所有位向左偏移 n 次, 右边用0补齐</span></span><br><span class="line"><span class="comment">        &gt;&gt;  // 右移：a &gt;&gt; n; 将 a 中的所有位向右偏移 n 次, 左边用0补齐</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>详情见以下示例：<br><a id="more"></a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// &amp; 与( and )运算， 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当且仅当 a 和 b 都为 1 时，操作 a&amp;b 返回 1。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;b 为 0。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0xAC: 10101100</span></span><br><span class="line">    <span class="comment">// 0xF0: 11110000</span></span><br><span class="line">    num := <span class="number">0xAC</span> &amp; <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 10100000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// | 或( or )运算， 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当且仅当 a 和 b 都为 0 时，操作 a|b 返回 0。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;b 为 1。</span></span><br><span class="line">    num = <span class="number">0xAC</span> | <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 11111100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ^ 非、异或( xor )运算， 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当且仅当 a!=b 时，操作 a^b 返回 1。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;b 为 0。</span></span><br><span class="line">    num = <span class="number">0xAC</span> ^ <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 01011100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;^ 与非( and not )运算, 使用 &amp; 后，再使用 ^ 操作的简写</span></span><br><span class="line">    <span class="comment">// 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当 a=1, b=0 时，操作 a&amp;^b 返回 1。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;^b 为 0。</span></span><br><span class="line">    num = <span class="number">0xAC</span> &amp;^ <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 00001100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt; 左移运算符</span></span><br><span class="line">    <span class="comment">// a &lt;&lt; n; 将 a 中的所有位向左偏移 n 次, 右边用0补齐</span></span><br><span class="line">    num2 := <span class="number">32</span> <span class="comment">// num2: 100000</span></span><br><span class="line">    num2 &lt;&lt;= <span class="number">2</span>  <span class="comment">// num2 = num2 &lt;&lt; 2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num2)  <span class="comment">// num: 10000000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; 右移运算符</span></span><br><span class="line">    <span class="comment">// a &gt;&gt; n; 将 a 中的所有位向右偏移 n 次, 左边用0补齐</span></span><br><span class="line">    num2 = <span class="number">32</span></span><br><span class="line">    num2 &gt;&gt;= <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num2)  <span class="comment">// num: 001000</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer_Paused</title>
      <link href="/2019/09/05/%E5%89%91%E6%8C%87offer_05_/"/>
      <url>/2019/09/05/%E5%89%91%E6%8C%87offer_05_/</url>
      
        <content type="html"><![CDATA[<p>刷题平台<a href="https://www.lintcode.com" target="_blank" rel="noopener">LintCode</a> 对 Go 语言的支持不是很好， 暂停记录</p>]]></content>
      
      
      
        <tags>
            
            <tag> lintcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wangwg</title>
      <link href="/2019/09/05/wangwg/"/>
      <url>/2019/09/05/wangwg/</url>
      
        <content type="html"><![CDATA[<p>Try again, please!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Wangwg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer_04 根据前序遍历和中序遍历树构造二叉树</title>
      <link href="/2019/09/04/%E5%89%91%E6%8C%87offer_04_%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A0%91%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/09/04/%E5%89%91%E6%8C%87offer_04_%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A0%91%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Question0073：根据前序遍历和中序遍历树构造二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given preorder and inorder traversal of a tree, construct the binary tree.</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line">Input：[],[]</span><br><span class="line">Output：&#123;&#125;</span><br><span class="line">Explanation:</span><br><span class="line">The binary tree is null</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line">Input：[2,1,3],[1,2,3]</span><br><span class="line">Output：&#123;2,1,3&#125;</span><br><span class="line">Explanation:</span><br><span class="line">The binary tree is as follows</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="思路及实现">思路及实现</span></h2><ul><li>前序遍历：中、左、右 </li><li>中序遍历：左、中、右</li><li>后序遍历：左、右、中</li></ul><ol><li>根据前序遍历找出根节点，在中序遍历中找出对应位置idx</li><li>那么可知[1: 1 + idx]为左子树，[idx + 1 : ]为右子树</li><li>递归查找至叶子节点，即中序遍历中只有一个元素为止</li><li>最后返回根节点所对应的二叉树</li></ol><p>实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param preorder: A list of integers that preorder traversal of a tree</span></span><br><span class="line"><span class="comment"> * @param inorder: A list of integers that inorder traversal of a tree</span></span><br><span class="line"><span class="comment"> * @return: Root of a tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildTree</span> <span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="comment">// write your code here</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(preorder) ==<span class="number">0</span> || <span class="built_in">len</span>(inorder) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">root := &amp;TreeNode&#123;</span><br><span class="line">Val: preorder[<span class="number">0</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 叶子节点，即中序遍历中只有一个元素为止</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根节点在中序遍历中对应位置idx</span></span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> inorder &#123;</span><br><span class="line"><span class="keyword">if</span> root.Val == v &#123;</span><br><span class="line">idx = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.Left = BuildTree(preorder[<span class="number">1</span> : <span class="number">1</span> + idx], inorder[ : idx])</span><br><span class="line">root.Right = BuildTree(preorder[idx + <span class="number">1</span> : ], inorder[idx + <span class="number">1</span> : ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="测试">测试</span></h2><ol><li>ginkgo bootstrap 创建测试入口文件 (e.g. find_minimum_in_rotated_sorted_array_suite_test.go)</li><li>ginkgo generate 创建独立测试文件 (e.g. find_minimum_in_rotated_sorted_array_test.go)</li><li>编写测试用例如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> problem0073_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">. <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">. <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line"></span><br><span class="line">. <span class="string">"lintcode/0073_construct_binary_tree_from_preorder_and_inorder_traversal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"ConstructBinaryTreeFromPreorderAndInorderTraversal"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">It(<span class="string">"Preorder = [], Inorder = []"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> preorder, inorder []<span class="keyword">int</span></span><br><span class="line">Expect(BuildTree(preorder, inorder)).To(BeNil())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">It(<span class="string">"Preorder = [2, 1, 3], Inorder = [1, 2, 3]"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">preorder, inorder := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">root := BuildTree(preorder, inorder)</span><br><span class="line">Expect(root.Left.Val).To(Equal(<span class="number">1</span>))</span><br><span class="line">Expect(root.Right.Val).To(Equal(<span class="number">3</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Running Suite: 0073ConstructBinaryTreeFromPreorderAndInorderTraversal Suite</span><br><span class="line">===========================================================================</span><br><span class="line">Random Seed: 1567610724</span><br><span class="line">Will run 2 of 2 specs</span><br><span class="line"></span><br><span class="line">••</span><br><span class="line">Ran 2 of 2 Specs <span class="keyword">in</span> 0.000 seconds</span><br><span class="line">SUCCESS! -- 2 Passed | 0 Failed | 0 Pending | 0 Skipped</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Ginkgo ran 1 suite <span class="keyword">in</span> 2.364254032s</span><br><span class="line">Test Suite Passed</span><br></pre></td></tr></table></figure><h2><span id="说明">说明</span></h2><ul><li>相关内容为阶梯训练《剑指 Offer 》刷题笔记。</li><li>刷题平台：<a href="https://www.lintcode.com" target="_blank" rel="noopener">LintCode</a></li><li>语言： <a href="https://golang.google.cn/doc/" target="_blank" rel="noopener">Golang</a></li><li>测试框架：<a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">Ginkgo</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> lintcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer_03 寻找旋转排序数组中的最小值</title>
      <link href="/2019/09/04/%E5%89%91%E6%8C%87offer_03_%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2019/09/04/%E5%89%91%E6%8C%87offer_03_%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>Question0159：寻找旋转排序数组中的最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Suppose a sorted array is rotated at some pivot unknown to you beforehand.</span><br><span class="line">(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</span><br><span class="line">Find the minimum element.</span><br><span class="line"></span><br><span class="line">e.g.</span><br><span class="line">Input：[4, 5, 6, 7, 0, 1, 2]</span><br><span class="line">Output：0</span><br><span class="line">Explanation：</span><br><span class="line">The minimum value in an array is 0.</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="思路及实现">思路及实现</span></h2><ol><li>假设未旋转，则返回数组首元素</li><li>旋转了，可当作两个有序数组的集合，找出临界点。使用二分法查找出左边比右边大的元素，即该右边元素为数组最小元素。</li></ol><p>实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param nums: a rotated sorted array</span></span><br><span class="line"><span class="comment"> * @return: the minimum number in the array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindMin</span> <span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设 nums[3, 4, 5, 6, 0, 1, 2] 为递增数组旋转</span></span><br><span class="line"><span class="comment">// 可当作两个有序数组的集合，使用二分法查找出左边比右边大的元素，即数组最小元素</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="comment">// 若数组未旋转，直接返回首元素</span></span><br><span class="line"><span class="keyword">for</span> nums[left] &gt; nums[right] &#123;</span><br><span class="line">mid := (left + right) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">left = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="测试">测试</span></h2><ol><li>ginkgo bootstrap 创建测试入口文件 (e.g. find_minimum_in_rotated_sorted_array_suite_test.go)</li><li>ginkgo generate 创建独立测试文件 (e.g. find_minimum_in_rotated_sorted_array_test.go)</li><li>编写测试用例如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> problem0159_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">. <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">. <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line"></span><br><span class="line">. <span class="string">"lintcode/0159_find_minimum_in_rotated_sorted_array"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"FindMinimumInRotatedSortedArray"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">It(<span class="string">"未旋转的递增数组"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">Expect(FindMin(nums)).To(Equal(<span class="number">-1</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">It(<span class="string">"旋转后的递增数组"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">Expect(FindMin(nums)).To(Equal(<span class="number">-1</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">It(<span class="string">"数组大小为1"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">Expect(FindMin(nums)).To(Equal(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Running Suite: 0159.FindMinimumInRotatedSortedArray Suite</span><br><span class="line">=========================================================</span><br><span class="line">Random Seed: 1567609538</span><br><span class="line">Will run 3 of 3 specs</span><br><span class="line"></span><br><span class="line">•••</span><br><span class="line">Ran 3 of 3 Specs <span class="keyword">in</span> 0.000 seconds</span><br><span class="line">SUCCESS! -- 3 Passed | 0 Failed | 0 Pending | 0 Skipped</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Ginkgo ran 1 suite <span class="keyword">in</span> 2.300838251s</span><br><span class="line">Test Suite Passed</span><br></pre></td></tr></table></figure><h2><span id="说明">说明</span></h2><ul><li>相关内容为阶梯训练《剑指 Offer 》刷题笔记。</li><li>刷题平台：<a href="https://www.lintcode.com" target="_blank" rel="noopener">LintCode</a></li><li>语言： <a href="https://golang.google.cn/doc/" target="_blank" rel="noopener">Golang</a></li><li>测试框架：<a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">Ginkgo</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> lintcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer_02 翻转链表</title>
      <link href="/2019/08/29/%E5%89%91%E6%8C%87offer_02_%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/08/29/%E5%89%91%E6%8C%87offer_02_%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>Question0035：翻转一个链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;null</span><br><span class="line">Output: 3-&gt;2-&gt;1-&gt;null</span><br><span class="line"></span><br><span class="line">Challenge:</span><br><span class="line">Reverse it in-place and in one-pass</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="思路及实现">思路及实现</span></h2><p>链表翻转，且不能占用额外空间。思路如下（以链表 1-&gt;2-&gt;3-&gt;null 为例）：</p><ol><li>声明逆转链表头节点 Prev （注：当前 head 节点指向 1）</li><li>创建临时节点 temp 保存 2及之后的链接（即 2 -&gt; 3 -&gt; null）， head 节点指向 Prev （逆转列表头节点，即 1 -&gt; null）</li><li>Prev = head 对Prev重新赋值，得到 1-&gt; null</li><li>head = temp 原链表则变成 2 -&gt; 3 -&gt; null</li><li>重复以上步骤，直到 head 节点为 null</li><li>翻转链表后， 3 -&gt; 2 -&gt; 1 -&gt; null</li></ol><p>具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 增加节点</span></span><br><span class="line"><span class="comment"> * func (f *ListNode) Append(NewNode *ListNode) &#123;</span></span><br><span class="line"><span class="comment"> *     if f.Next == nil &#123;</span></span><br><span class="line"><span class="comment"> *         f.Next = NewNode</span></span><br><span class="line"><span class="comment"> *     &#125; else &#123;</span></span><br><span class="line"><span class="comment"> *         currentNode := f.Next</span></span><br><span class="line"><span class="comment"> *         currentNode.Next = NewNode</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param head: n</span></span><br><span class="line"><span class="comment"> * @return: The new head of reversed linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span> <span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明翻转链表头节点 Prev</span></span><br><span class="line">    <span class="keyword">var</span> prev *ListNode</span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 创建临时节点 temp ，保存原链表除头节点外所有节点</span></span><br><span class="line">temp := head.Next</span><br><span class="line">head.Next = prev</span><br><span class="line"><span class="comment">// Prev重新赋值，变成翻转链表头节点 1-&gt; null</span></span><br><span class="line">prev = head</span><br><span class="line"><span class="comment">// head 重新赋值为原链表头节点</span></span><br><span class="line">head = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="测试">测试</span></h2><ol><li>ginkgo bootstrap 创建测试入口文件 (e.g. 0366_fibonacci_sequence_suite_test.go)</li><li>ginkgo generate 创建独立测试文件 (e.g. 0366_fibonacci_sequence_test.go)</li><li>编写测试用例如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> problem0035_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">. <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">. <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line"></span><br><span class="line">. <span class="string">"lintcode/0035_reverse_linked_list"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"0035ReverseLinkedList"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">It(<span class="string">"链表为空"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">head := &amp;ListNode&#123;&#125;</span><br><span class="line">Reverse(head)</span><br><span class="line">Expect(head.Val).To(Equal(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">It(<span class="string">"链表不为空"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">head := &amp;ListNode&#123;&#125;</span><br><span class="line">head.Append(&amp;ListNode&#123;<span class="number">1</span>, <span class="literal">nil</span>&#125;)</span><br><span class="line">head.Append(&amp;ListNode&#123;<span class="number">2</span>, <span class="literal">nil</span>&#125;)</span><br><span class="line">head.Append(&amp;ListNode&#123;<span class="number">3</span>, <span class="literal">nil</span>&#125;)</span><br><span class="line">Reverse(head)</span><br><span class="line">Expect(head.Val).To(Equal(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Running Suite: 0035ReverseLinkedList Suite</span><br><span class="line">==========================================</span><br><span class="line">Random Seed: 1567084485</span><br><span class="line">Will run 2 of 2 specs</span><br><span class="line"></span><br><span class="line">••</span><br><span class="line">Ran 2 of 2 Specs <span class="keyword">in</span> 0.000 seconds</span><br><span class="line">SUCCESS! -- 2 Passed | 0 Failed | 0 Pending | 0 Skipped</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Ginkgo ran 1 suite <span class="keyword">in</span> 1.029308444s</span><br><span class="line">Test Suite Passed</span><br></pre></td></tr></table></figure><h2><span id="说明">说明</span></h2><ul><li>相关内容为阶梯训练《剑指 Offer 》刷题笔记。</li><li>刷题平台：<a href="https://www.lintcode.com" target="_blank" rel="noopener">LintCode</a></li><li>语言： <a href="https://golang.google.cn/doc/" target="_blank" rel="noopener">Golang</a></li><li>测试框架：<a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">Ginkgo</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> lintcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer_01 斐波那契数列</title>
      <link href="/2019/08/29/%E5%89%91%E6%8C%87offer_01_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2019/08/29/%E5%89%91%E6%8C%87offer_01_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>Question0366: 查找斐波纳契数列中第 N 个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所谓的斐波纳契数列是指：</span><br><span class="line">    · 前2个数是 0 和 1 。</span><br><span class="line">    · 第 i 个数是第 i-1 个数和第i-2 个数的和。</span><br><span class="line"></span><br><span class="line">斐波纳契数列的前10个数字是：</span><br><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ...</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="思路及实现">思路及实现</span></h2><p>乍一看，递归解法蹭蹭蹭蹭地出来，于是乎，以下解法直接提交。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param n: an integer</span></span><br><span class="line"><span class="comment"> * @return: an ineger f(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">2</span>) + Fibonacci(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pia ，出师不利，Time Limit Exceeded！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你的代码运行时间超过了限制，检查你的时间复杂度。TLE通常是由死循环造成的，思考一下你的时间复杂度是否是最优的。</span><br></pre></td></tr></table></figure><p>得，递归太慢，老老实实用循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param n: an integer</span></span><br><span class="line"><span class="comment"> * @return: an ineger f(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret, n1, n2 := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i ++ &#123;</span><br><span class="line">            ret, n1 = n1 + n2, n2</span><br><span class="line">            n2 = ret</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="测试">测试</span></h2><ol><li>ginkgo bootstrap 创建测试入口文件 (e.g. 0366_fibonacci_sequence_suite_test.go)</li><li>ginkgo generate 创建独立测试文件 (e.g. 0366_fibonacci_sequence_test.go)</li><li>编写测试用例如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> problem0366_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo/extensions/table"</span></span><br><span class="line">    . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line"></span><br><span class="line">    . <span class="string">"lintcode/0366_fibonacci_sequence"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"0366FibonacciSequence"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DescribeTable(<span class="string">"the &gt; inequality"</span>,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>, expected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">            Expect(Fibonacci(x) == y).To(Equal(expected))</span><br><span class="line">        &#125;,</span><br><span class="line">        Entry(<span class="string">"The first number is 0"</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>),</span><br><span class="line">        Entry(<span class="string">"The Second number is 1"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>),</span><br><span class="line">        Entry(<span class="string">"The 47th number is 12"</span>, <span class="number">47</span>, <span class="number">12</span>, <span class="literal">false</span>),</span><br><span class="line">        Entry(<span class="string">"The 47th number is 1836311903"</span>, <span class="number">47</span>, <span class="number">1836311903</span>, <span class="literal">true</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Running Suite: 0366FibonacciSequence Suite</span><br><span class="line">==========================================</span><br><span class="line">Random Seed: 1567081080</span><br><span class="line">Will run 4 of 4 specs</span><br><span class="line"></span><br><span class="line">••••</span><br><span class="line">Ran 4 of 4 Specs <span class="keyword">in</span> 0.001 seconds</span><br><span class="line">SUCCESS! -- 4 Passed | 0 Failed | 0 Pending | 0 Skipped</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Ginkgo ran 1 suite <span class="keyword">in</span> 1.369636547s</span><br><span class="line">Test Suite Passed</span><br></pre></td></tr></table></figure><h2><span id="说明">说明</span></h2><ul><li>相关内容为阶梯训练《剑指 Offer 》刷题笔记。</li><li>刷题平台：<a href="https://www.lintcode.com" target="_blank" rel="noopener">LintCode</a></li><li>语言： <a href="https://golang.google.cn/doc/" target="_blank" rel="noopener">Golang</a></li><li>测试框架：<a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">Ginkgo</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> lintcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ginkgo 测试框架使用入门</title>
      <link href="/2019/08/28/Ginkgo%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/08/28/Ginkgo%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1><span id="ginkgo-介绍">Ginkgo 介绍</span></h1><p>Ginkgo是一个BDD风格的Go测试框架，旨在帮助您有效地编写富有表现力的综合测试。</p><h2><span id="安装及依赖">安装及依赖</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/onsi/ginkgo/ginkgo</span><br><span class="line">$ go get github.com/onsi/gomega/...</span><br></pre></td></tr></table></figure><p>在 $GOPATH 下使用上述命令安装 ginkgo 及匹配器 gomega。使用过程中遇到的问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Failed to compile 0344-reverse-string:</span><br><span class="line"></span><br><span class="line"><span class="comment"># leetcode/case/0344-reverse-string</span></span><br><span class="line">package leetcode/<span class="keyword">case</span>/0344-reverse-string_test</span><br><span class="line">        imports github.com/onsi/gomega</span><br><span class="line">        imports github.com/onsi/gomega/matchers</span><br><span class="line">        imports golang.org/x/net/html/charset</span><br><span class="line">        imports golang.org/x/text/encoding: cannot find package <span class="string">"golang.org/x/text/encoding"</span> <span class="keyword">in</span> any of:</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/golang.org/x/text/encoding (from <span class="variable">$GOROOT</span>)</span><br><span class="line">        /Users/night/go_learn/src/golang.org/x/text/encoding (from <span class="variable">$GOPATH</span>)</span><br></pre></td></tr></table></figure></p><p>问题为 text/encoding 包未找到，解决方案如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src</span><br><span class="line">$ mkdir golang.org/x/</span><br><span class="line">$ <span class="built_in">cd</span> golang.org/x</span><br><span class="line">$  git <span class="built_in">clone</span> https://github.com/golang/text.git text</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2><span id="初步使用">初步使用</span></h2><p>1、执行 <strong>ginkgo bootstrap</strong> ，生成 package_suite_test.go 模版文件，包含入口函数，例子如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo bootstrap                                 </span><br><span class="line">Generating ginkgo <span class="built_in">test</span> suite bootstrap <span class="keyword">for</span> problem0344 <span class="keyword">in</span>:</span><br><span class="line">        0344_reverse_string_suite_test.go</span><br><span class="line">$</span><br><span class="line">$ cat 0344_reverse_string_suite_test.go</span><br><span class="line">package problem0344_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">        . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">        . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Test0344ReverseString(t *testing.T) &#123;</span><br><span class="line">        RegisterFailHandler(Fail)</span><br><span class="line">        RunSpecs(t, <span class="string">"0344ReverseString Suite"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、执行 <strong>ginkgo generate xx</strong>（ xx 可不写，默认为当前文件夹名）是， 生成 xx_test.go ，例子如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo generate                         </span><br><span class="line">Generating ginkgo <span class="built_in">test</span> <span class="keyword">for</span> 0344ReverseString <span class="keyword">in</span>:</span><br><span class="line">  0344_reverse_string_test.go</span><br><span class="line">$</span><br><span class="line">$ cat 0344_reverse_string_test.go</span><br><span class="line">package problem0344_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">        . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line"></span><br><span class="line">        . <span class="string">"leetcode/case/0344-reverse-string"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var _ = Describe(<span class="string">"0344ReverseString"</span>, <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>常规做法： package_suite_test.go 作为入口， xx_test.go 作为各个文件的测试源文件。</p><h2><span id="功能点">功能点</span></h2><p>常用的模块及介绍如下表。</p><table><thead><tr><th style="text-align:left">模块</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">It</td><td style="text-align:left">It 包含的代码为一个测试用例</td></tr><tr><td style="text-align:left">Specify</td><td style="text-align:left">和 It 功能一致， 可作为别名在适当位置替换 It</td></tr><tr><td style="text-align:left">Describe</td><td style="text-align:left">将一个或多个测试用例归类</td></tr><tr><td style="text-align:left">Context</td><td style="text-align:left">同 Describe</td></tr><tr><td style="text-align:left">BeforeEach</td><td style="text-align:left">每个测试用例执行前执行该段代码</td></tr><tr><td style="text-align:left">AftreEach</td><td style="text-align:left">每个测试用例执行后执行该段代码</td></tr><tr><td style="text-align:left">JustBeforeEach</td><td style="text-align:left">在 BeforeEach 之后，执行测试用例之前执行</td></tr><tr><td style="text-align:left">JustAfterEach</td><td style="text-align:left">在执行测试用例之后，AftreEach之前执行</td></tr><tr><td style="text-align:left">BeforeSuite</td><td style="text-align:left">在该测试集执行前执行， package_suite_test.go 中 RunSpecs 执行之前</td></tr><tr><td style="text-align:left">AfterSuite</td><td style="text-align:left">无论是否有任何测试失败，该函数都会在测试集执行后运行</td></tr><tr><td style="text-align:left">By</td><td style="text-align:left">打印信息（字符串），只会在测试例失败后打印，一般用于调试和定位问题</td></tr><tr><td style="text-align:left">Fail</td><td style="text-align:left">标志该测试例运行结果为失败，并打印里面的信息</td></tr></tbody></table><p>通过实验得到以下顺序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Running Suite: 0344ReverseString Suite</span><br><span class="line">======================================</span><br><span class="line">Random Seed: 1567008418</span><br><span class="line">Will run 1 of 1 specs</span><br><span class="line"></span><br><span class="line">BeforeSuite &gt; </span><br><span class="line">BeforeEach &gt; input =  zx</span><br><span class="line">JustBeforeEach &gt; append <span class="string">'l'</span> to input =  zxl</span><br><span class="line">Describe &gt; It &gt; After ReverseString input =  lxz</span><br><span class="line">JustAfterEach &gt; change input to =  I</span><br><span class="line">AfterEach &gt; input =  I</span><br><span class="line">•AfterSuite &gt; </span><br><span class="line"></span><br><span class="line">Ran 1 of 1 Specs <span class="keyword">in</span> 0.000 seconds</span><br><span class="line">SUCCESS! -- 1 Passed | 0 Failed | 0 Pending | 0 Skipped</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Ginkgo ran 1 suite <span class="keyword">in</span> 2.023695404s</span><br><span class="line">Test Suite Passed</span><br></pre></td></tr></table></figure></p><h2><span id="f-p-x-规范">F、P、X 规范</span></h2><p>将容器（测试用例） Describe ， Context ， It ，和 Measure 标记为待定，通过添加 P 或者 X 即可。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PDescribe(<span class="string">"some behavior"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">PContext(<span class="string">"some scenario"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">PIt(<span class="string">"some assertion"</span>)</span><br><span class="line">PMeasure(<span class="string">"some measurement"</span>)</span><br><span class="line"></span><br><span class="line">XDescribe(<span class="string">"some behavior"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">XContext(<span class="string">"some scenario"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">XIt(<span class="string">"some assertion"</span>)</span><br><span class="line">XMeasure(<span class="string">"some measurement"</span>)</span><br></pre></td></tr></table></figure></p><p>跳过容器（测试用例），使用 skip 。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">It(<span class="string">"should do something, if it can"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !someCondition &#123;</span><br><span class="line">        Skip(<span class="string">"special condition wasn't met"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assertions go here</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>F 含义 Focus ，使用后表专注于当前容器（测试用例）。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FDescribe(<span class="string">"some behavior"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">FContext(<span class="string">"some scenario"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">FIt(<span class="string">"some assertion"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notice</span></span><br><span class="line">FDescribe(<span class="string">"outer describe"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    It(<span class="string">"A"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)   <span class="comment">// Not do</span></span><br><span class="line">    FIt(<span class="string">"B"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)  <span class="comment">// Do</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2><span id="并行测试">并行测试</span></h2><p>Ginkgo 支持并行运行规范。通过生成单独的 go test 进程并为共享队列中的每个进程提供规范来实现此目的。这对于 BDD 测试框架很重要，因为闭包的共享上下文不能在进程中很好地并行化。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ginkgo -p  <span class="comment">// 自动检测要生成的最佳测试节点数</span></span><br><span class="line">ginkgo -nodes=N  <span class="comment">// 使用 -nodes 指定要生成的节点数</span></span><br><span class="line">ginkgo -nodes=N -stream <span class="comment">// 设置 -stream 实时查看各个并行测试套件的输出</span></span><br></pre></td></tr></table></figure></p><h2><span id="表驱动测试">表驱动测试</span></h2><p>包 github.com/onsi/ginkgo/extensions/table 提供表扩展功能，即根据每个 Entry 生成对应的 It（容器、测试用例）。使用方式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> table_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo/extensions/table"</span></span><br><span class="line"></span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">    . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"Math"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DescribeTable(<span class="string">"the &gt; inequality"</span>,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>, expected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">            Expect(x &gt; y).To(Equal(expected))</span><br><span class="line">        &#125;,</span><br><span class="line">        Entry(<span class="string">"x &gt; y"</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>),</span><br><span class="line">        Entry(<span class="string">"x == y"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>),</span><br><span class="line">        Entry(<span class="string">"x &lt; y"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其等同于的展开格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> table_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">    . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"Math"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Describe(<span class="string">"the &gt; inequality"</span>,</span><br><span class="line">        It(<span class="string">"x &gt; y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(<span class="number">1</span> &gt; <span class="number">0</span>).To(Equal(<span class="literal">true</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        It(<span class="string">"x == y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(<span class="number">0</span> &gt; <span class="number">0</span>).To(Equal(<span class="literal">false</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        It(<span class="string">"x &lt; y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(<span class="number">0</span> &gt; <span class="number">1</span>).To(Equal(<span class="literal">false</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2><span id="异步测试">异步测试</span></h2><p>Go很好地兼容并发。Ginkgo为有效测试异步性提供支持。通过下面的例子进一步了解：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It(<span class="string">"should post to the channel, eventually"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> DoSomething(c)</span><br><span class="line">    Expect(&lt;-c).To(ContainSubstring(<span class="string">"Done!"</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>此测试将阻塞，直到通道收到响应 c 。死锁或超时是这种测试的常见故障模式，在这种情况下，常见的模式是在函数的底部添加一个 select 语句，并包含一个 &lt;-time.After(X) 指定超时的通道。</p><p>Ginkgo 内置了这种模式。 body 所有非容器块（It s，BeforeEach es，AfterEach es，JustBeforeEach es，JustAfterEach es 和 Benchmark s）中的 done Done 函数都可以采用可选参数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">It(<span class="string">"should post to the channel, eventually"</span>, <span class="function"><span class="keyword">func</span><span class="params">(done Done)</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> DoSomething(c)</span><br><span class="line">    Expect(&lt;-c).To(ContainSubstring(<span class="string">"Done!"</span>))</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">&#125;, <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></p><p>Done 是一个 chan interface{} 。当 Ginkgo 检测到 done Done 参数已被请求时，它将该 body 函数作为 goroutine 运行，并使用必要的逻辑将其包装以应用超时断言。您必须关闭done 通道，或向其发送一些内容（任何内容）以告知 Ginkgo 测试已结束。如果测试在超时期限后没有结束，那么 Ginkgo 将无法通过测试并继续进行下一次测试。</p><p>默认超时为 1 秒。您可以通过 float64 在 body 函数后面传递（以秒为单位）来修改此超时。在该示例中，我们将超时设置为 0.2 秒。</p><h2><span id="基准测试">基准测试</span></h2><p>Ginkgo 使用 Measure 块来衡量代码的性能。 Measure 作用于单个测试用例（It 的位置）。传递给的闭包函数 Measure 必须带 Benchmarker 参数。将 Benchmarker 用于测量的运行时间和记录任意的数值。还必须Measure在闭包函数后传递一个整数，这表示您的代码 Measure 将执行的次数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Measure(<span class="string">"it should do something hard efficiently"</span>, <span class="function"><span class="keyword">func</span><span class="params">(b Benchmarker)</span></span> &#123;</span><br><span class="line">    runtime := b.Time(<span class="string">"runtime"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        output := SomethingHard()</span><br><span class="line">        Expect(output).To(Equal(<span class="number">17</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Ω(runtime.Seconds()).Should(BeNumerically(<span class="string">"&lt;"</span>, <span class="number">0.2</span>), <span class="string">"SomethingHard() shouldn't take too long."</span>)</span><br><span class="line"></span><br><span class="line">    b.RecordValue(<span class="string">"disk usage (in MB)"</span>, HowMuchDiskSpaceDidYouUse())</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>将运行闭包功能 10 次，聚合”运行时”和”磁盘使用”的数据。然后， ginkgo 打印执行的性能数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">• [MEASUREMENT]</span><br><span class="line">Suite</span><br><span class="line">    it should <span class="keyword">do</span> something hard efficiently</span><br><span class="line"></span><br><span class="line">    Ran 10 samples:</span><br><span class="line">    runtime:</span><br><span class="line">      Fastest Time: 0.01s</span><br><span class="line">      Slowest Time: 0.08s</span><br><span class="line">      Average Time: 0.05s ± 0.02s</span><br><span class="line"></span><br><span class="line">    disk usage (<span class="keyword">in</span> MB):</span><br><span class="line">      Smallest: 3.0</span><br><span class="line">       Largest: 5.2</span><br><span class="line">       Average: 3.9 ± 0.4</span><br></pre></td></tr></table></figure></p><p>Measures 可以在测试中与 It s 一起执行。如果你想只运行It s，你可以将 –skipMeasurements 标志传递给 ginkgo 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Test </tag>
            
            <tag> ginkgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试角度学习 groupcache</title>
      <link href="/2019/08/21/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0groupcache/"/>
      <url>/2019/08/21/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0groupcache/</url>
      
        <content type="html"><![CDATA[<h1><span id="groupcache-介绍">groupcache 介绍</span></h1><p>“groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.”。作者如是介绍该项目，翻译后的意思为：groupcache 是一个缓存和缓存填充库，在许多情况下用作 memcached 的替代品。</p><p>It is paused now..<br><a id="more"></a></p><h2><span id="测试角度学习-groupcache">测试角度学习 groupcache</span></h2><ul><li><strong>ring hash 算法</strong></li><li><strong>LRU 算法</strong></li><li><strong>singleflight 算法</strong></li><li>rpc</li><li>Protocol Buffers</li><li>groupcache 实现逻辑</li></ul><p>1、 consistenthash_test.go</p><p>2、 lru_test.go</p><p>3、 singleflight_test.go</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试角度学习 cache2go</title>
      <link href="/2019/08/20/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0cache2go/"/>
      <url>/2019/08/20/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0cache2go/</url>
      
        <content type="html"><![CDATA[<h1><span id="cache2go-介绍">cache2go 介绍</span></h1><p>“Concurrency-safe golang caching library with expiration capabilities.”。作者如是介绍该项目，翻译后的意思为：存在心跳机制且并发安全的go语言缓存库。</p><h3><span id="tips">tips</span></h3><p>测试行为，而非实施。 “The public API of a package declare this is what(行为) I do, not this is <del>how(实施)</del> I do it.”</p><h3><span id="测试角度学习-cache2go">测试角度学习 cache2go</span></h3><p>我们知道心跳机制、并发安全是 cache2go 的两大特点，那么肯定是测试的重点了。 【Cachetable 简称 table，cacheitem 简称 item】</p><p>首先查看 cache_test.go ，可以获得以下信息：<br><a id="more"></a></p><table><thead><tr><th>测试点</th><th>描述</th><th>具体因子</th></tr></thead><tbody><tr><td>TestCache</td><td>创建 table ，添加 item ，获取 item 基本信息</td><td>Cache, table.Add, table.Value, item.AccessCount, item.LifeSpan, item.AccessedOn、item.CreateOn</td></tr><tr><td>TestCacheExpire</td><td><strong>心跳机制</strong>：超出 lifeSpan 存活时间后自动消除 item</td><td>Cache, table.Add, table.Value</td></tr><tr><td>TestExists</td><td>table 表中是否存在 item</td><td>Cache, table.Add, <strong>table.Exists</strong></td></tr><tr><td>TestNotFoundAdd</td><td>table 表中是否存在 item ，若不存在则添加</td><td>Cache, table.Add, <strong>table.NotFoundAdd</strong></td></tr><tr><td>TestNotFoundAddConcurrency</td><td><strong>并发安全</strong>： NotFoundAdd</td><td>Cache, <strong>table.NotFoundAdd</strong>, <strong>table.Foreach</strong></td></tr><tr><td>TestCacheKeepAlive</td><td><strong>心跳机制</strong>： item 重新计时</td><td>Cache, table.Add, <strong>item.KeepAlive</strong>, table.Exists</td></tr><tr><td>TestDelete</td><td>从 table 表中删除 item</td><td>Cache, table.Add, table.Value, <strong>table.Delete</strong></td></tr><tr><td>TestFlush</td><td>清空 table 表所有 item</td><td>Cache, table.Add, <strong>table.Flush</strong>, table.Value</td></tr><tr><td>TestCount</td><td>table 表中 item 数量</td><td>Cache, table.Add, table.Value, <strong>table.Count</strong></td></tr><tr><td>TestDataLoader</td><td>访问不存在的 item 时会触发 loadData 回调函数</td><td>Cache, <strong>table.SetDataLoader</strong>, NewCacheItem, table.Value, table.Exists, item.Data</td></tr><tr><td>TestAccessCount</td><td>返回访问频率高的 count 条 item</td><td>Cache, table.Add, table.Value, <strong>table.MostAccessed</strong></td></tr><tr><td>TestCallbacks</td><td>增加、删除或超时移除情况下触发回调</td><td>Cache, <strong>table.SetAddItemCallback</strong>, <strong>table.SetAboutToDeleteItemCallback</strong>, <strong>item.SetAboutToExpireCallback</strong>, table.Add</td></tr><tr><td>TestCallbackQueue</td><td>设置、增加、清除 item 的回调函数正常</td><td>Cache, item.Key, table.Add, <strong>table.AddAddedItemCallback</strong>, <strong>table.AddAboutToDeleteItemCallback</strong>, <strong>item.AddAboutToExpireCallback</strong>, <strong>table.RemoveAddedItemCallbacks</strong>, <strong>table.RemoveAboutToDeleteItemCallback</strong>, <strong>item.SetAboutToExpireCallback</strong>, <strong>item.RemoveAboutToExpireCallback</strong></td></tr><tr><td>TestLogger</td><td>设置 logger 正常</td><td>Cache, <strong>table.SetLogger</strong>, table.Add</td></tr></tbody></table><p>再查看benchmark_test.go，可得：</p><table><thead><tr><th>基准测试</th><th>具体因子</th><th>描述</th></tr></thead><tbody><tr><td>BenchmarkNotFoundAdd</td><td>基准测试： NotFoundAdd</td><td>Cache, <strong>table.NotFoundAdd</strong></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go Testing;How,What,Why</title>
      <link href="/2019/07/28/Go_Testing/"/>
      <url>/2019/07/28/Go_Testing/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>关于 Go 测试，我们应该知道测试方式（或者说测试手段）、测试对象及测试原因。</p><h2><span id="how-测试方式">How 测试方式</span></h2><h3><span id="测试实现">测试实现</span></h3><p>举个例子。针对字符串分割函数（如下），实现单元测试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> goTest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下且一样的包名 goTest ，写一个简单的 go 测试函数，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> goTest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Split(<span class="string">"a/b/c"</span>, <span class="string">"/"</span>)</span><br><span class="line">    want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"expected: %v, got: %v"</span>, want, got)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数必须以 Test 开头， 且必须携带一个 *testing.T 参数。 t *testing.T 提供改测试函数的打印、跳过、失败功能。</p><h3><span id="测试执行">测试执行</span></h3><a id="more"></a><p>当前目录下，执行 go test ，输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      goTest  0.005s</span><br></pre></td></tr></table></figure><p>如果项目中存在多个 package ，若要执行所有包的测试可以在项目根目录下使用 go test ./… ，输出如下（例子：github.com/mattn/go-sqlite3）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span> ./...</span><br><span class="line">ok      github.com/mattn/go-sqlite3 14.693s</span><br><span class="line">?       github.com/mattn/go-sqlite3/upgrade [no <span class="built_in">test</span> files]</span><br></pre></td></tr></table></figure><h3><span id="代码测试覆盖率">代码测试覆盖率</span></h3><p>还是以字符串分割函数为例， 获取当前代码测试覆盖率方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span> -coverprofile=c.out</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      goTest  0.005s</span><br></pre></td></tr></table></figure><p>数据显示覆盖率为 100% 。若要以 HTML 方式显示可以使用命令 <strong>go tool cover -html=c.out</strong> 。</p><p>【tip】 一行命令 cover 获取当前目录下的代码测试覆盖度。 在 ~/.bashrc 中添加如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cover</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> t=$(mktemp -t cover)</span><br><span class="line">    go <span class="built_in">test</span> <span class="variable">$COVERFLAGS</span> -coverprofile=<span class="variable">$t</span> <span class="variable">$@</span> \</span><br><span class="line">      &amp;&amp; go tool cover -func=<span class="variable">$t</span> \</span><br><span class="line">      &amp;&amp; unlink <span class="variable">$t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后获取的测试覆盖度结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      goTest  0.008s</span><br><span class="line">goTest/wwg_split.go:7:  Split       100.0%</span><br><span class="line">total:             (statements)     100.0%</span><br></pre></td></tr></table></figure><p>问题：<strong>测试覆盖率 100% ，结束了？</strong></p><p>多个测试用例的情况下，使用表组测试用例装填。更改 TestSplit 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep <span class="keyword">string</span></span><br><span class="line">        want []<span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,  <span class="comment">// trailing sep</span></span><br><span class="line">        &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"expected: %v, got: %v"</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加测试用例 trailing sep 后，执行测试，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    wwg_split_test.go:23: expected: [a b c], got: [a b c ]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    goTest0.005s</span><br></pre></td></tr></table></figure><p>根据该结果很难一下子在表组测试用例中查出是哪条。可以将 <strong>表组测试用例实现改为 map 形式</strong> ，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep <span class="keyword">string</span></span><br><span class="line">        want []<span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="string">"simple"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"wrong sep"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"no sep"</span>: &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">t.Errorf(<span class="string">"%s expected: %v, got: %v"</span>, name, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    wwg_split_test.go:23: trailing sep expected: [a b c], got: [a b c ]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAILgoTest0.005s</span><br></pre></td></tr></table></figure><p>Sub tests 使用，及 ‘%#v’ format 使用，更改 TestSplit 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;</span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep <span class="keyword">string</span></span><br><span class="line">want []<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="string">"simple"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"no sep"</span>: &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">t.Fatalf(<span class="string">"%s expected: %#v, got: %#v"</span>, name, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit/trailing_sep (0.00s)</span><br><span class="line">        wwg_split_test.go:24: trailing sep expected: []string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, got: []string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">""</span>&#125;</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAILgoTest0.005s</span><br></pre></td></tr></table></figure><p>更好的打印格式，可以访问：</p><ul><li><a href="https://github.com/k0kubun/pp" target="_blank" rel="noopener">https://github.com/k0kubun/pp</a></li><li><a href="https://github.com/davecgh/go-spew" target="_blank" rel="noopener">https://github.com/davecgh/go-spew</a></li><li><a href="https://github.com/google/go-cmp" target="_blank" rel="noopener">https://github.com/google/go-cmp</a></li></ul><p>使用 google/go-cmp 优化打印， 更改 TestSplit 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line">           diff := cmp.Diff(tc.want, got)</span><br><span class="line">           <span class="keyword">if</span> diff != <span class="string">""</span> &#123;</span><br><span class="line">               t.Fatalf(diff)</span><br><span class="line">           &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit/trailing_sep (0.00s)</span><br><span class="line">        wwg_split_test.go:29:   []string&#123;</span><br><span class="line">              <span class="string">"a"</span>,</span><br><span class="line">              <span class="string">"b"</span>,</span><br><span class="line">              <span class="string">"c"</span>,</span><br><span class="line">            + <span class="string">""</span>,</span><br><span class="line">              &#125;</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAILgoTest0.005s</span><br></pre></td></tr></table></figure><p>修复bug后 Split 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result**</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  goTest0.006s</span><br><span class="line"></span><br><span class="line">&gt; cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok  goTest0.006s</span><br><span class="line">goTest/wwg_split.go:7:Split100.0%</span><br><span class="line">total:                  (statements)100.0%</span><br></pre></td></tr></table></figure><h2><span id="what-测试对象">What 测试对象</span></h2><p>Q_1：Go 应该测试所有因子吗？<br><br>A_1：显然不是。</p><p>Q_2：何时编写测试? 1.编码完成后？ 2.编码前？ 3.其他人遍写测试，像QA、TE？ 4.项目设计人员编写测试？<br><br>A_2：编码的同时编写测试代码（TDD）Article <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">TheThreeRulesOfTdd</a></p><p>Q_3：C 单元测试对象是 function ，Java 单元测试对象是 Class ，类内部的方法， Go 的单元测试对象是？<br><br>A_3：package 。测试行为，而非实施。 “The public API of a package declare this is <strong>what</strong>(行为) I do, not this is <strong>how</strong>(实施) I do it.”</p><h2><span id="why-测试原因">Why 测试原因</span></h2><p>即使你不做代码测试，别人也会做。自己发现 issues 总比别人发现来得好，不是吗？<br></p><ol><li>大部分的测试(自动化)应该是开发人员自己做。</li><li>手工测试不应该是你测试的主体部分，因为手工测试的复杂度为O(n)</li><li>测试可以确保您始终可以运送主分支</li><li>测试确定软件行为（做什么、不做什么）</li><li>测试让你有信心修改他人的代码</li></ol><h2><span id="总结">总结</span></h2><ul><li>You should write tests.</li><li>You should write tests at the same time as you write your code.<br>Each Go package is a self contained unit.</li><li>Your tests should assert the observable behaviour of your package, not its implementation.</li><li>You should design your packages around their behaviour, not their implementation.</li></ul><p>【注】部分资料源于GopherChina 2019 - ‘How to write testable code’</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用数据库关键字</title>
      <link href="/2019/05/20/Mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/05/20/Mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>drop</td><td>注销</td><td>drop table cacaca;</td></tr><tr><td>create</td><td>创建</td><td>create table cacaca( id int(11), desc varchar(255),   content text, isOK tinyint(1));</td></tr><tr><td>delete</td><td>删除</td><td>delete from cacaca where id = 1;</td></tr><tr><td>insert</td><td>插入</td><td>insert into cacaca values(1, ‘desc oo’, ‘content oo’);<br> insert into cacaca (desc)values(‘memeda’);</td></tr><tr><td>update</td><td>更新</td><td>update cacaca set desc = “desc oooo” where id = 1;</td></tr><tr><td>select</td><td>查找</td><td>select * from cacaca;</td></tr><tr><td>alter</td><td>更改</td><td>alter table cacaca change desc desc text;   [ 更改列数据类型 ]<br> alter table cacaca change desc desc_t varchar(255);   [ 更改列名称 ]</td></tr><tr><td>null</td><td>空</td><td>select * from cacaca where desc is [not] null;   [ 判断null使用 is[not] ]</td></tr><tr><td>distinct</td><td>去重</td><td>select distinct desc from cacaca;</td></tr><tr><td>between</td><td>在…之间</td><td>select * from cacaca where id [not] between 1 and 2; <br> [ 列名id的值(不)在[1, 2]之间 ]</td></tr><tr><td>like</td><td>模糊匹配</td><td>select * from cacaca where desc like ‘_sec%’;<br> [ 其中 _ 匹配 一个字符，% 匹配 一个或多个 ]</td></tr><tr><td>limit</td><td>截断</td><td>select * from cacaca order by id desc limit 1,2;  <br>[ limit 前一个参数默认为0，即第一条数据，后一个参数为选择多少项。<br>该句的意思是：通过id 降序查询cacaca数据表中的第2项以及第3项 ]</td></tr><tr><td>order by</td><td>排序</td><td>select * from cacaca order by id [<strong>asc</strong> or <strong>desc</strong>];  <br>[  默认asc升序，可选desc降序系列 ]</td></tr><tr><td>group by</td><td>分组</td><td>select isOK,count(*) from cacaca group by isOK;（分组查询isOK总数量）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ 指针</title>
      <link href="/2019/05/13/%E6%8C%87%E9%92%88_C++/"/>
      <url>/2019/05/13/%E6%8C%87%E9%92%88_C++/</url>
      
        <content type="html"><![CDATA[<h2><span id="指针">指针</span></h2><p>指针是一个变量，其存储的是值的地址，而不是值本身。 值的地址，只需对变量应用地址运算符(&amp;)，即可得到其地址；例如home是一个变量，则&amp;home是它的地址。   *运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址存储的值。例如L: mainly是一个指针，则mainly是一个地址，*mainly表示存储在该地址处的值。</p><h4><span id="1声明指针">1.声明指针</span></h4><p>要声明指向特定类型的指针，请使用下面的格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointerName;  <span class="comment">// 示例： double * pn;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针声明的格式。传统上C程序员使用该格式：</span></span><br><span class="line"><span class="keyword">int</span> *ptr;  <span class="comment">// 强调 *ptr 是一个int类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而C++大多数使用下述格式：</span></span><br><span class="line"><span class="keyword">int</span>* ptr;  <span class="comment">// 强调 int* 是一种类型 -- 指向int的指针</span></span><br></pre></td></tr></table></figure></p><p>其实，对于编译器来说空格所处位置没有区别，甚至可以不加空格，直接： int*ptr； 但是要知道的是，声明多个指针时，对每个指针变量名，都需要使用一个* 。</p><a id="more"></a><h4><span id="2给指针赋值">2.给指针赋值</span></h4><p>应将内存地址赋给指针。可以对变量名应用&amp;运算符，来获得被命名的内存地址，new运算符返回未命名的内存地址。示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;  <span class="comment">// 将higgens地址赋给pt</span></span><br><span class="line"></span><br><span class="line">pc = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">pa = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br></pre></td></tr></table></figure></p><h4><span id="3对指针解除引用">3.对指针解除引用</span></h4><p>对指针解除引用意味着获得指针指向的值。一种是对指针应用解除引用或间接值运算符(*)来解除引用。另一种是使用数组表示法，例如，pn[0]与(*p)是一样的。</p><h4><span id="4指针-数组和指针算术">4.指针、数组和指针算术</span></h4><p>指针与数组基本等价的原因在于指针算数(pointer arithmetic)和C++内部处理数组的方式。先看看算数，将整数变量加1后，其值增加1；但将指针变量加1后，增加的量等于它指向的<strong>类型的字节数</strong>。 通常，使用数组表示法时，C++都执行下面的转换：arrayname[i] ==&gt; *(arrayname + i); 如果使用的是指针，而不是数组名，C++也执行同样的转换：pointername[i] ==&gt;*(pointername + i);</p><h4><span id="5指针与const">5.指针与const</span></h4><p>将const关键字用于指针，有两种方式：</p><ol><li>将指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值；</li><li>将指针本身声明为常量，这样可以防止改变指向指针指向的位置。<br>首先，声明一个指向常量的指针pt：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure></li></ol><p>该声明支持，pt指向一个const int(这里为21)，因此不能使用pt来修改这个值，换句话说，*pt的值为const，不能被修改。但pt的声明并不意味着它指向的值实际上就是一个常量，而只是<strong>意味着对pt而言，这个值是常量</strong>。 例如，pt指向age，而age不是const。可以通过age变量修改age的值，但不能使用pt指针来修改它。</p><ul><li>将常规变量的地址赋给常规指针</li><li>将常规变量的地址赋给指向const的指针</li><li>将const变量的地址赋给指向const的指针</li><li>将const变量的地址赋给常规指针  (❌)</li></ul><p>尽可能使用const。 将指针参数声明为指向常量数据的指针有两条理由：</p><ol><li>可以避免由于无意间修改数据导致的编程错误</li><li>如果使用const使得函数能够处理const和非const实参，否则将只能接受非const数据<br>如果条件允许，应将指针行参声明为指向const的指针。</li></ol><h4><span id="函数指针">函数指针</span></h4><p>与数据项类似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。<br>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的特征标(参数列表)，也就是说，声明应像函数原型那样指出有关函数的信息。例如原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pam</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// prototype</span></span><br><span class="line"><span class="comment">// 指针类型如下</span></span><br><span class="line"><span class="keyword">double</span> (*pf)(<span class="keyword">int</span>);  <span class="comment">// *pf = pam</span></span><br></pre></td></tr></table></figure></p><p>由于pam是函数，因此(*pf)也是函数，pf就是<strong>函数指针</strong>。<br>通常，要声明指向特定类型的函数的指针时，可以首先编写这种函数的原型，然后用(*pf)替换函数名。这样pf就是这类函数的指针。<br>由于括号的优先级比*运算符高，因此在声明中使用括号将*pf括起。 *pf(int)意味着pf()是一个返回指针的函数，而(*pf)(int)意味着pf是一个指向函数的指针。</p><p>使用typedef简化函数指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字typedef可以创建类型别名：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> real;    <span class="comment">// 给double创建个别名real</span></span><br><span class="line">                        <span class="comment">// 将别名当作标识符进行声明，并在开头使用关键子typedef</span></span><br><span class="line"><span class="comment">// 因此，可将p_func声明为函数指针类型的别名：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">double</span>* (*p_func)(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>);  <span class="comment">// p_func(函数指针) 一个类型别名 </span></span><br><span class="line">p_func p1 = f1;</span><br><span class="line"></span><br><span class="line">p_func pa[<span class="number">3</span>] = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>学习设计模式总结<br><img src="/设计模式学习.jpg" alt="设计模式"></p><p>更详细的见<a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Patterns </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件可测试性</title>
      <link href="/2019/05/11/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E6%B5%8B%E6%80%A7/"/>
      <url>/2019/05/11/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E6%B5%8B%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>分析软件的可测试性，旨在加快测试进度、提高测试效率等。</p><p>软件的可测试性是指被测对象具有某些特征，如：<strong>可控制、可分解、稳定、易理解、可观察</strong>等。</p><p>可测性设计时需要保证的是：</p><ol><li>不对软件本身的功能产生影响；</li><li>不产生附加的测试。</li></ol><p><img src="/可测试性.jpg" alt="可测试性"></p><a id="more"></a><p>可测试性的具体体现：</p><ol><li>功能测试  相关点：功能、流程、输入输出等</li><li>性能测试  相关点：查询、保存、统计、刷新、显示、传输、响应、下载等</li><li>压力测试  相关点：大数据量的导入导出/计算/恢复/查询/接收时间、测试脚本/工具等</li><li>容错测试  相关点：断网、断电、死机等</li><li>并发测试  相关点：登录、提交、数据库操作等</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>查找算法之二分查找</title>
      <link href="/2019/05/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/05/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>查找算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>查找条件</th></tr></thead><tbody><tr><td>顺序查找</td><td>O(n)</td><td>O(1)</td><td>无序或有序</td></tr><tr><td>二分查找(折半查找)</td><td>O(log~2~n)</td><td>O(1)</td><td>有序</td></tr><tr><td>插值查找</td><td>O(log~2~(log~2~n))</td><td>O(1)</td><td>有序</td></tr><tr><td>斐波那契查找</td><td>O(log~2~n)</td><td>O(1)</td><td>有序</td></tr><tr><td>哈希查找</td><td>O(1)</td><td>O(n)</td><td>无序或有序</td></tr></tbody></table><a id="more"></a><h1><span id="二分查找">二分查找</span></h1><h3><span id="原理">原理</span></h3><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。 </p><h3><span id="二分查找应用场景的局限性">二分查找应用场景的局限性</span></h3><p>二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。但应用场景有很大局限性。</p><ol><li><p>二分查找依赖的是顺序表结构(eg: 数组)</p></li><li><p>二分查找针对的有序数据</p></li><li><p>数据量太小或太大均不适合使用二分查找 ( 数据量小的话，使用顺序查找；数据量大的话，由于依赖的是数组该数据结构，需要连续的大内存空间。而内存中会出现无这么大的内存块，导致申请空间失败)</p></li></ol><p><strong>[注意点]</strong>  容易出错的细节有：终止条件、区间上下界更新方法、返回值选择</p><h3><span id="简单实现">简单实现</span></h3><p>递归与非递归简单实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">    非递归实现</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high):</span><br><span class="line">            <span class="comment"># mid = (low + high) // 2</span></span><br><span class="line">            <span class="comment"># mid = low + (high - low) // 2  # 比上述的优点是: 防止数组过大，(low+high)越界</span></span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span>  <span class="comment"># 比上述的优点是: 位运算比除法运算要快得多</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        递归实现</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.bsearchInternally(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>, target)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearchInternally</span><span class="params">(self, nums: List[int], low: int, high: int, target: int )</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> low &gt; high:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> self.bsearchInternally(nums, mid+<span class="number">1</span>, high, target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.bsearchInternally(nums, low, mid<span class="number">-1</span>, target)</span><br></pre></td></tr></table></figure><h3><span id="变形问题">变形问题</span></h3><p>常见的二分查找变形问题</p><ul><li>查找第一个值等于给定值的元素</li><li>查找最后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_0</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 4</span></span><br><span class="line"><span class="string">            Output: 2</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更改相等时 逻辑处理</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> nums[mid - <span class="number">1</span>] != target</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_1</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 4</span></span><br><span class="line"><span class="string">            Output: 4</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更改相等时 逻辑处理</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> nums[mid + <span class="number">1</span>] != target</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_2</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 3</span></span><br><span class="line"><span class="string">            Output: 2</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> (nums[mid - <span class="number">1</span>] &lt; target):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_3</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 5</span></span><br><span class="line"><span class="string">            Output: 4</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> (nums[mid + <span class="number">1</span>] &gt; target):</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复杂度分析</title>
      <link href="/2019/05/01/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/01/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>如何分析、统计算法的执行效率(执行时间)和资源消耗(占用空间)？<br></p><p>数据结构和算法 解决的问题是”如何让计算机更快时间、更省空间”， 所以需要从执行时间、占用空间两个维度评估算法性能。复杂度分析 是时间复杂度和空间复杂度的统称，描述的是算法执行时间(占用空间)与数据规模的增长关系。和 性能测试 相比。复杂度分析不依赖执行环境、成本低、效率高、指导性强<br>        <strong>[复杂度分析]</strong> 一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法<br>        <strong>[性能的基准测试]</strong> 事后统计法：跑代码，通过统计、监控，得到算法执行的时间和占用的内存大小。得到的实验结果，受环境、数据规模大小因素影响较大<br><a id="more"></a></p><h3><span id="1大o表示法">1.大O表示法</span></h3><p>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n)) 表示。（其中T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而n往往表示的是数据规模）</p><p>分析法则：只关注循环执行次数最多的一段代码，若嵌套则相乘，若不同且规模不一则相加。</p><p>常用的复杂度级别：</p><ol><li>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包含有常数阶[O(1)]、对数阶[O(logn)]、线性阶[O(n)]、线性对数阶[O(nlogn)]、平方阶[O(n^2^)]、立方阶[O(n^3^)]、……</li><li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，性能极差。包含有指数阶[O(2^n^)]、阶乘阶[O(n!)]</li></ol><h3><span id="2时间复杂度知识点">2.时间复杂度知识点</span></h3><p>最好情况时间复杂度(best case time complexity)，在最理想的情况下，执行代码的时间复杂度。</p><p>最坏情况时间复杂度(worst case time complexity)，在最糟糕的情况下，执行代码的时间复杂度。</p><p>平均情况时间复杂度(average case time complexity)，即概率论中的加权平均值，也称期望值。所以平局时间复杂度= 加权平均时间复杂度= 期望平均时间复杂度</p><p>均摊时间复杂度(amortised case time complexity)，摊还分析法。<br>例子：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时许关系。这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平潭到其它那些时间复杂度较低的操作上。<br>一般，在能够应用均摊时间复杂度分析的场合，摊还时间复杂度就等于最好情况时间复杂度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2018/12/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="排序">排序</span></h1><table><thead><tr><th style="text-align:left">排序算法</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">最差时间复杂度</th><th style="text-align:left">空间复杂度</th><th style="text-align:left">数据对象稳定性</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">数组不稳定、链表稳定</td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(log~2~n)</td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">希尔排序</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n)</td><td style="text-align:left">稳定</td></tr></tbody></table><a id="more"></a><h3><span id="冒泡排序">冒泡排序</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序:（bubble sort）是一种简单的排序算法。</span></span><br><span class="line"><span class="string">    它重复地遍历要排列的序列，一词比较2个元素，如果它们的顺序错误就交换。遍历数列的</span></span><br><span class="line"><span class="string">工作是重复地进行直到没有再需要交换。即排序完成。步骤如下:</span></span><br><span class="line"><span class="string">    1. 比较相邻的元素，如果第二个比第一个大（升序），就交换；</span></span><br><span class="line"><span class="string">    2. 对每一对相邻元素作同样的工作，从开始的一对到最后的一对，找出最大的元素；</span></span><br><span class="line"><span class="string">    3. 针对所有的元素，重复以上步骤，除了最后一个；</span></span><br><span class="line"><span class="string">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n)  [表示遍历一次发现没有任何可以交换的元素，排序结束]</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">    <span class="comment">#外层确定次数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span> -j):</span><br><span class="line">        <span class="comment">#for i in range(0, n-1):</span></span><br><span class="line">        <span class="comment">#内存确定一个数（最大或最小）</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == count:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    bubble_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure><h3><span id="插入排序">插入排序</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序（insertion sort）是一种简单直观的排序算法。工作原理：</span></span><br><span class="line"><span class="string">    通过构建有序序列，对于未排序数据，在已排序序列中向前扫描，找到相应位置并插入。</span></span><br><span class="line"><span class="string">    插入排序实现上，在从后向前扫描中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n) (升序，序列已处于升序状态)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># alist = [93,      54, 77, 31, 44, 55, 226]</span></span><br><span class="line"><span class="comment"># alist = [54, 93,      77, 31, 44, 55, 226]</span></span><br><span class="line"><span class="comment"># alist = [54, 77, 93,      31, 44, 55, 226]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 从右边的无序序列中取出多少个元素执行这样的过程</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># i = [1, 2, 3, ...,n-1]</span></span><br><span class="line">        <span class="comment"># i 代表内层循环起始值</span></span><br><span class="line">        i = j</span><br><span class="line">        <span class="comment"># 执行从右边的无序序列中取出第一个元素，即 i 位置的元素，然后插入到前面的正确位置中</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[i] &lt; alist[i<span class="number">-1</span>]:</span><br><span class="line">                alist[i<span class="number">-1</span>], alist[i] = alist[i], alist[i<span class="number">-1</span>]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># i=j j-1 j-2 ... 1   # range(j, 0, -1)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def insert_sort(alist):</span></span><br><span class="line"><span class="comment">#     for i in range(1, len(alist)):</span></span><br><span class="line"><span class="comment">#         for j in range(i, 0, -1):</span></span><br><span class="line"><span class="comment">#             if alist[i] &lt; alist[i-1]:</span></span><br><span class="line"><span class="comment">#                 alist[i], alist[i-1] = alist[i-1], alist[i]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    select_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure><h3><span id="选择排序">选择排序</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序 (selection sort)是一种简单直观的排序算法。工作原理如下：</span></span><br><span class="line"><span class="string">    1. 在未排序序列中找到最小（大）元素存放到序列的起始位置；</span></span><br><span class="line"><span class="string">    2. 从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</span></span><br><span class="line"><span class="string">    3. 依次类推，直到排序完成。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># alist = [17, 20,     93, 54, 43, 67, 224, 23]</span></span><br><span class="line"><span class="comment">#          0   1       2   3   4   5   6    7</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># j = [0, 1, 2, 3..., n-2 ]</span></span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    select_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure><h3><span id="快速排序">快速排序</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序（Quicksort）是一种比较排序，这意味着它可以对任何类型的项目进行</span></span><br><span class="line"><span class="string">排序.稳定的排序，这意味着相同的排序项目的相对顺序不会被保留，快速排序可以在数组</span></span><br><span class="line"><span class="string">上就地操作，需要少量额外的内存来执行排序。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [54,26,93,17,77,31,44,55,20]</span></span><br><span class="line"><span class="comment">#               |  |                    |</span></span><br><span class="line"><span class="comment">#      pivotvalue leftmark -&gt;       &lt;- rightmark</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    temp = data_list[leftmark]</span></span><br><span class="line"><span class="comment">#    data_list[leftmark] = data_list[rightmark]</span></span><br><span class="line"><span class="comment">#    data_list[rightmark] = temp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(data_list)</span>:</span></span><br><span class="line">    quickSortHlp(data_list,<span class="number">0</span>,len(data_list)<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSortHlp</span><span class="params">(data_list,first,last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        splitpoint = partition(data_list,first,last)</span><br><span class="line">        quickSortHlp(data_list,first,splitpoint<span class="number">-1</span>)</span><br><span class="line">        quickSortHlp(data_list,splitpoint+<span class="number">1</span>,last)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(data_list,first,last)</span>:</span></span><br><span class="line">    pivotvalue = data_list[first]</span><br><span class="line">    leftmark = first+<span class="number">1</span></span><br><span class="line">    rightmark = last</span><br><span class="line">    done = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">       <span class="keyword">while</span> leftmark &lt;= rightmark <span class="keyword">and</span> data_list[leftmark] &lt;= pivotvalue:</span><br><span class="line">           leftmark = leftmark + <span class="number">1</span></span><br><span class="line">       <span class="keyword">while</span> data_list[rightmark] &gt;= pivotvalue <span class="keyword">and</span> rightmark &gt;= leftmark:</span><br><span class="line">           rightmark = rightmark <span class="number">-1</span></span><br><span class="line">       <span class="keyword">if</span> rightmark &lt; leftmark:</span><br><span class="line">           done = <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           temp = data_list[leftmark]</span><br><span class="line">           data_list[leftmark] = data_list[rightmark]</span><br><span class="line">           data_list[rightmark] = temp</span><br><span class="line">    <span class="comment"># print(data_list,data_list[rightmark],rightmark)</span></span><br><span class="line">    temp = data_list[first]</span><br><span class="line">    data_list[first] = data_list[rightmark]</span><br><span class="line">    data_list[rightmark] = temp</span><br><span class="line">    <span class="keyword">return</span> rightmark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    quickSort(data_list)</span><br><span class="line">    print(data_list)</span><br></pre></td></tr></table></figure><h3><span id="希尔排序">希尔排序</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序（shell sort）是插入排序的一种，也称缩小增量排序。是直接插入排序算法</span></span><br><span class="line"><span class="string">的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序</span></span><br><span class="line"><span class="string">算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被</span></span><br><span class="line"><span class="string">分成一组，算法终止。</span></span><br><span class="line"><span class="string">    基本思想：</span></span><br><span class="line"><span class="string">    将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长，</span></span><br><span class="line"><span class="string">列数更少）来进行。最后整个表就只有1列了。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： 根据步长序列的不同而不同</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># i = gap</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 插入算法，与普通的插入算法区别就是gap步长</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># i = [gap, gap+1, ..., n-1]</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i-gap]:</span><br><span class="line">                    alist[i], alist[i-gap] = alist[i-gap], alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    shell_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure><h3><span id="归并排序">归并排序</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   归并排序（）采用分治法的一个典型应用。</span></span><br><span class="line"><span class="string">   归并排序的思想就是先递归分解数组，再合并数组。</span></span><br><span class="line"><span class="string">   将数组分解最小之后，然后合并2个有序数组，基本思路就是比较两个数组的最前面的数，</span></span><br><span class="line"><span class="string">谁小就先取谁，取了之后相应的指针往后移一位。然后再比较，直至一个数组为空，最后把另</span></span><br><span class="line"><span class="string">一个数组的剩余部分复制过来即可。</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  #最优时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">  #最坏时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">  #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># left 采用归并排序后有序的新的列表</span></span><br><span class="line">    left_list = merge_sort(alist[:mid])</span><br><span class="line">    <span class="comment"># right 采用归并排序后有序的新的列表</span></span><br><span class="line">    right_list = merge_sort(alist[mid:])</span><br><span class="line">    <span class="comment"># 将两个有序子列表合并为一个新列表</span></span><br><span class="line">    <span class="comment"># merge(left, right)</span></span><br><span class="line">    left_pointer, right_pointer = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left_pointer &lt; len(left_list) <span class="keyword">and</span> right_pointer &lt; len(right_list):</span><br><span class="line">        <span class="keyword">if</span> left_list[left_pointer] &lt;= right_list[right_pointer]:</span><br><span class="line">            result.append(left_list[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_list[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line">    result += left_list[left_pointer:]</span><br><span class="line">    result += right_list[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    sorted = merge_sort(data_list)</span><br><span class="line">    print(sorted)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>To You</title>
      <link href="/2018/12/09/zxl01/"/>
      <url>/2018/12/09/zxl01/</url>
      
        <content type="html"><![CDATA[<p>20181209，两年零一天。<br>我喜欢你！</p>]]></content>
      
      
      
        <tags>
            
            <tag> zlinna </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 基础学习</title>
      <link href="/2018/12/05/git_learning/"/>
      <url>/2018/12/05/git_learning/</url>
      
        <content type="html"><![CDATA[<h4><span id="git安装及配置">git安装及配置</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Linux/Debian安装git方式</span><br><span class="line">    命令行：sudo apt-get install git</span><br><span class="line">    源码：下载后，依次  &apos;&apos;./config&apos;  &apos;make&apos;  &apos;sudo make install&apos;</span><br><span class="line">配置:</span><br><span class="line">    git config --global user.name &quot;username&quot;</span><br><span class="line">    git config --global user.email &quot;username@example.com&quot;</span><br><span class="line">    git config --global color.ui true  # 让Git显示颜色</span><br></pre></td></tr></table></figure><h4><span id="工作区与暂存区">工作区与暂存区</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本地仓库: git init初始化的文件夹</span><br><span class="line">  &gt; 工作区: 当前文件夹(除隐藏目录外)</span><br><span class="line">  &gt; 版本库: .git目录</span><br><span class="line">     &gt; 暂存区: stage或index文件夹</span><br><span class="line">     &gt; 分支: .git目录下master、develop、...</span><br><span class="line">     &gt; ...</span><br></pre></td></tr></table></figure><h4><span id="本地git命令使用">本地git命令使用</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">初始化一个仓库: git init</span><br><span class="line">添加文件至暂存区: git add &lt;file&gt;  (git add file.txt)</span><br><span class="line">提交文件至仓库: git commit -m &lt;message&gt;  (git commit -m &quot;test for commit&quot;)</span><br><span class="line">查看当前工作区状态： git status</span><br><span class="line">查看修改内容: git diff</span><br><span class="line"></span><br><span class="line">查看提交历史(一行显示): git log （git log --pretty==oneline）</span><br><span class="line">查看命令历史: git reflog</span><br><span class="line">回退版本: git reset --hard &lt;commit_id&gt;</span><br><span class="line">丢弃工作区的修改: git checkout -- &lt;file&gt;</span><br><span class="line">删除暂存区中文件: git rm &lt;file&gt;</span><br><span class="line">查看远程库信息: git remote -v</span><br></pre></td></tr></table></figure><a id="more"></a><h4><span id="远程git命令使用">远程git命令使用</span></h4><p>前提: 已绑定一个远程仓库(<em>github</em>、<em>bitbucket</em>、…)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关联远程仓库: git remote add origin git@github.com:zlinna/zlinna.github.io.git</span><br><span class="line">当前分支master推送到远程并关联: git push -u origin master</span><br><span class="line">推送内容到远程: git push origin master</span><br><span class="line"></span><br><span class="line">克隆一个远程仓库: git clone git@github.com:zmonarch/wangwg.git</span><br></pre></td></tr></table></figure><h4><span id="git分支">git分支</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建与合并分支:</span><br><span class="line">  创建分支: git branch develop</span><br><span class="line">  切换分支: git checkout develop</span><br><span class="line">  创建并切换分支: git checkout -b develop</span><br><span class="line">  查看当前分支: git branch</span><br><span class="line">  合并develop分支到master: </span><br><span class="line">      1.先切换至master分支: git branch master</span><br><span class="line">      2.合并develop分支: git merge develop （git merge --no-ff -m &quot;merge no-ff&quot; develop）</span><br><span class="line">  删除分支: git branch -d develop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解决合并冲突:</span><br><span class="line">  当两个分支都对同一个文件做了修改，并且修改点不一。此时合并会有冲突，git status可以查看冲突的文件。</span><br><span class="line">直接打开冲突的文件:</span><br><span class="line">  ...</span><br><span class="line">  &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">  Creating a new branch is quick &amp; simple.</span><br><span class="line">  =======</span><br><span class="line">  Creating a new branch is quick AND simple.</span><br><span class="line">  &gt;&gt;&gt;&gt;&gt;&gt;&gt; Bug</span><br><span class="line">其中git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，修改后保存并提交</span><br><span class="line">  ...</span><br><span class="line">  Creating a new branch is quick</span><br><span class="line">由 git log --graph --pretty=oneline --abbrev-commit 可查看分支合并情况</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Bug分支处理:</span><br><span class="line">  1.保存当前develop分支工作现场: git stash</span><br><span class="line">  2.确认修复bug的分支并处理: </span><br><span class="line">      a.切换分支: git branch master</span><br><span class="line">      b.创建临时分支并进入: git checkout -b issue-01</span><br><span class="line">  3.修复问题后并提交: git commit -m &quot;Bug is fixed&quot;</span><br><span class="line">  4.切换master分支并合并:</span><br><span class="line">      a.切换分支: git checkout master</span><br><span class="line">      b.合并至master: git merge --no-ff -m &quot;merged bug fix 01&quot; issue-01</span><br><span class="line">      c.删除issue-01分支: git branch -d issue-01</span><br><span class="line">  5.切换至develop分支工作:</span><br><span class="line">      a.切换分支: git checkout develop</span><br><span class="line">      b.查看保存的工作环境: git stash list</span><br><span class="line">      c.恢复并删除: git stash pop  </span><br><span class="line">      (git stash apply &lt;stash@&#123;0&#125;&gt; / git stash drop &lt;stash@&#123;0&#125;&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Feature分支:</span><br><span class="line">  1.从develop分支创建一个feature分支: git checkout -b feature_test</span><br><span class="line">  2.修复或开发完后提交</span><br><span class="line">      a.选择强制删除分支: git branch -D feature_test</span><br><span class="line">      b.切换develop分支进行合并</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">多人协作模式:</span><br><span class="line">  1.从本地推送分支，使用git push origin &lt;branch-name&gt;，如果推送失败，先用git pull抓取远程的新提交</span><br><span class="line">      a.如果有冲突，要先处理冲突</span><br><span class="line">  2.在本地创建和远程分支对应的分支: git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br><span class="line">  3.建立本地分支/远程分支的关联: git branch --set-upstream &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br><span class="line">  4.推送修改内容: git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h4><span id="git标签">git标签</span></h4><p>标签tag: 就是一个让人容易记住的有意义的名字，和某个commit绑在一起。</p><p>==注意==：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">新建标签: git tag &lt;tag_name&gt; &lt;commit_id&gt; (默认为HAED)</span><br><span class="line">新建带描述的标签: git tag -a &lt;tag_name&gt; -m &lt;tag_desc&gt; &lt;commit_id&gt;</span><br><span class="line">查看所有标签: git tag</span><br><span class="line">查看标签信息: git show &lt;tag_id&gt;</span><br><span class="line"></span><br><span class="line">本地删除标签: git tag -d &lt;tag_name&gt;</span><br><span class="line">推送单个标签到远程: git push origin &lt;tag_name&gt;</span><br><span class="line">推送所有标签到远程: git push origin --tags</span><br><span class="line">删除远程标签: git push origin :refs/tag/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure><h4><span id="自定义git">自定义git</span></h4><p>忽略特殊文件:  在当前工作中创建 .gitignore 文件，然后把要忽略的文件名填进去。 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">各种语言的git忽略配置文件</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">忽略文件的原则是: </span><br><span class="line">    1. 忽略操作系统自动生成的文件，比如缩略图等；</span><br><span class="line">    2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</span><br><span class="line">    3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</span><br></pre></td></tr></table></figure><p>配置别名:   <em>git config –global alias.==st== status</em></p><h4><span id="git命令">git命令</span></h4><table><thead><tr><th>Type</th><th>Commands</th><th style="text-align:right">Explanation Of Commands</th></tr></thead><tbody><tr><td>CREATE</td><td>git clone   ssh:<a href="mailto://user@domain.com" target="_blank" rel="noopener">//user@domain.com</a>/repo.git</td><td style="text-align:right">Clone an existing repository</td></tr><tr><td></td><td>git init</td><td style="text-align:right">Create a new local repository</td></tr><tr><td>LOCAL CHANGES</td><td>git status</td><td style="text-align:right">Changed files in your working directory</td></tr><tr><td></td><td>git diff</td><td style="text-align:right">Changes to tracked files</td></tr><tr><td></td><td>git add .</td><td style="text-align:right">Add all current changes to the next commit</td></tr><tr><td></td><td>git add -p ‘file’</td><td style="text-align:right">Add some changes in <file> to the next commit</file></td></tr><tr><td></td><td>git commit -a</td><td style="text-align:right">Commit all local changes in tracked files</td></tr><tr><td></td><td>git commit</td><td style="text-align:right">Commit previously staged changes</td></tr><tr><td></td><td>git commit –amend</td><td style="text-align:right">Change the last commit Don’t amend published commits!</td></tr><tr><td>COMMIT HISTORY</td><td>git log</td><td style="text-align:right">Show all commits, starting with newest</td></tr><tr><td></td><td>git log -p ‘file’</td><td style="text-align:right">Show changes over time for a specific file</td></tr><tr><td></td><td>git blame ‘file’</td><td style="text-align:right">Who changed what and when in <file></file></td></tr><tr><td>BRANCHES &amp; TAGS</td><td>git branch -av</td><td style="text-align:right">List all existing branches</td></tr><tr><td></td><td>git checkout ‘branch’</td><td style="text-align:right">Switch HEAD branch</td></tr><tr><td></td><td>git branch ‘new-branch’</td><td style="text-align:right">Create a new branch based on your current HEAD</td></tr><tr><td></td><td>git checkout –track ‘remote/bran-ch’</td><td style="text-align:right">Create a new tracking branch based on a remote branch</td></tr><tr><td></td><td>git branch -d ‘branch’</td><td style="text-align:right">Delete a local branch</td></tr><tr><td></td><td>git tag ‘tag-name’</td><td style="text-align:right">Mark the current commit with a tag</td></tr><tr><td>PDATE &amp; PUBLISH</td><td>git remote -v</td><td style="text-align:right">List all currently configured remotes</td></tr><tr><td></td><td>git remote show ‘remote’</td><td style="text-align:right">Show information about a remote</td></tr><tr><td></td><td>git remote add ‘shortname’ ‘url’</td><td style="text-align:right">Add new remote repository, named <remote></remote></td></tr><tr><td></td><td>git fetch &lt;remote’</td><td style="text-align:right">Download all changes from <remote>, but don‘t integrate into HEAD</remote></td></tr><tr><td></td><td>git pull ‘remote’ ‘branch’</td><td style="text-align:right">Download changes and directly <br>merge/integrate into HEAD</td></tr><tr><td></td><td>git push ‘remote’ ‘branch’</td><td style="text-align:right">Publish local changes on a remote</td></tr><tr><td></td><td>git branch -dr ‘remote/branch’</td><td style="text-align:right">Delete a branch on the remote</td></tr><tr><td></td><td>git push –tags</td><td style="text-align:right">Publish your tags</td></tr><tr><td>MERGE &amp; REBASE</td><td>git merge ‘branch’</td><td style="text-align:right">Merge <branch> into your current HEAD</branch></td></tr><tr><td></td><td>git rebase ‘branch’</td><td style="text-align:right">Rebase your current HEAD onto <branch>  Don‘t rebase published commits!</branch></td></tr><tr><td></td><td>git rebase –abort</td><td style="text-align:right">Abort a rebase</td></tr><tr><td></td><td>git rebase –continue</td><td style="text-align:right">Continue a rebase after resolving conflicts</td></tr><tr><td></td><td>git mergetool</td><td style="text-align:right">Use your configured merge tool to solve conflicts</td></tr><tr><td></td><td>git add ‘resolved-file’ <br> git rm ‘resolved-file’</td><td style="text-align:right">Use your editor to manually solve conflicts and (after resolving) mark file as resolved</td></tr><tr><td>UNDO</td><td>git reset –hard HEAD</td><td style="text-align:right">Discard all local changes in your working directory</td></tr><tr><td></td><td>git checkout HEAD ‘file’</td><td style="text-align:right">Discard local changes in a specific file</td></tr><tr><td></td><td>git revert ‘commit’</td><td style="text-align:right">Revert a commit (by producing a new commit with contrary changes)</td></tr><tr><td></td><td>git reset –hard ‘commit’</td><td style="text-align:right">Reset your HEAD pointer to a previous commit …and discard all   changes  since then</td></tr><tr><td></td><td>git reset ‘commit’</td><td style="text-align:right">…and preserve all changes as unstaged changes</td></tr><tr><td></td><td>git reset –keep ‘commit’</td><td style="text-align:right">…and preserve uncommitted local changes</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 基础学习</title>
      <link href="/2018/12/04/python_basic/"/>
      <url>/2018/12/04/python_basic/</url>
      
        <content type="html"><![CDATA[<h4><span id="一-类型与运算">一、类型与运算</span></h4><h5><span id="1寻求帮助">1.寻求帮助</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir(obj)          <span class="comment"># 简单的列出对象obj所包含的方法名称，返回一个字符串列表</span></span><br><span class="line">help(obj.func)    <span class="comment"># 查询obj.func的具体介绍和用法</span></span><br></pre></td></tr></table></figure><h5><span id="2测试类型的方法-推荐3">2.测试类型的方法 （推荐3）</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> type(L) == type([]):</span><br><span class="line">    print(<span class="string">"L is list"</span>）</span><br><span class="line"><span class="keyword">if</span> type(L) == list:</span><br><span class="line">    print(<span class="string">"L is list"</span>）</span><br><span class="line"><span class="keyword">if</span> isinstance(L, list):</span><br><span class="line">    print(<span class="string">"L is list"</span>）</span><br></pre></td></tr></table></figure><h5><span id="3python数据类型哈希不可哈希">3.Python数据类型：哈希/不可哈希</span></h5><p>哈希类型。不可变类型，可利用hash函数查看其hash值，也可以作为字典的key。具体有：</p><blockquote><p>数字类型：int, float, decimal.Decimal, fraction.Fraction, complex</p><p>字符串类型：str, bytes</p><p>元祖：tuple</p><p>冻结集合：frozenset</p><p>布尔类型：True， False</p><p>None</p></blockquote><p>不可哈希类型。可变类型，不可以作为字典的key。有：list, dict, set</p><a id="more"></a><h5><span id="4数字常量">4.数字常量</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span>, <span class="number">-1234</span>, <span class="number">0</span>, <span class="number">999999999</span>             <span class="comment"># 整数</span></span><br><span class="line"><span class="number">1.23</span>, <span class="number">1.</span>, <span class="number">3.14e-10</span>, <span class="number">4E210</span>, <span class="number">4.0e+210</span>   <span class="comment"># 浮点数</span></span><br><span class="line"><span class="number">0o177</span>, <span class="number">0x9ff</span>, <span class="number">0X9FF</span>, <span class="number">0b101010</span>         <span class="comment"># 八进制、十六进制、二进制数字</span></span><br><span class="line"><span class="number">3</span>+<span class="number">4j</span>, <span class="number">3.0</span>+<span class="number">4.0j</span>, <span class="number">3J</span>           <span class="comment"># 复数常量，也可以用complex(real, image)来创建</span></span><br><span class="line">hex(I), oct(I), bin(I)       <span class="comment"># 将十进制数转化为十六进制、八进制、二进制表示的“字符串”</span></span><br><span class="line">int(string, base)                     <span class="comment"># 将字符串转化为整数，base为进制数</span></span><br><span class="line"><span class="comment"># 2.x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数</span></span><br><span class="line">float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>), float(<span class="string">'nan'</span>)    <span class="comment"># 无穷大, 无穷小, 非数</span></span><br></pre></td></tr></table></figure><h5><span id="5数字的表达式操作符">5.数字的表达式操作符</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> x                           <span class="comment"># 生成器函数发送协议</span></span><br><span class="line"><span class="keyword">lambda</span> args: expression           <span class="comment"># 生成匿名函数</span></span><br><span class="line">x <span class="keyword">if</span> y <span class="keyword">else</span> z                     <span class="comment"># 三元选择表达式</span></span><br><span class="line">x <span class="keyword">and</span> y, x <span class="keyword">or</span> y, <span class="keyword">not</span> x            <span class="comment"># 逻辑与、逻辑或、逻辑非</span></span><br><span class="line">x <span class="keyword">in</span> y, x <span class="keyword">not</span> <span class="keyword">in</span> y                <span class="comment"># 成员对象测试</span></span><br><span class="line">x <span class="keyword">is</span> y, x <span class="keyword">is</span> <span class="keyword">not</span> y                <span class="comment"># 对象实体测试</span></span><br><span class="line">x&lt;y, x&lt;=y, x&gt;y, x&gt;=y, x==y, x!=y    <span class="comment"># 大小比较，集合子集或超集值相等性操作符</span></span><br><span class="line"><span class="number">1</span> &lt; a &lt; <span class="number">3</span>                         <span class="comment"># Python中允许连续比较</span></span><br><span class="line">x|y, x&amp;y, x^y                     <span class="comment"># 位或、位与、位异或</span></span><br><span class="line">x&lt;&lt;y, x&gt;&gt;y                        <span class="comment"># 位操作：x左移、右移y位</span></span><br><span class="line">+, -, *, /, //, %, **             <span class="comment"># 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算</span></span><br><span class="line">-x, +x, ~x                        <span class="comment"># 一元减法、识别、按位求补（取反）</span></span><br><span class="line">x[i], x[i:j:k]                    <span class="comment"># 索引、分片、调用</span></span><br><span class="line">int(<span class="number">3.14</span>), float(<span class="number">3</span>)               <span class="comment"># 强制类型转换</span></span><br></pre></td></tr></table></figure><h5><span id="6整数可计算所占位数">6.整数可计算所占位数</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a.bit_length()  <span class="comment"># 1位</span></span><br><span class="line">b = <span class="number">1024</span></span><br><span class="line">b.bit_length()  <span class="comment"># 11位</span></span><br></pre></td></tr></table></figure><h5><span id="7repr和str的区别">7.repr和str的区别</span></h5><ul><li>repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。</li><li>str格式：打印语句，转化成一种对用户更加友好的格式。</li></ul><h5><span id="8数字相关模块">8.数字相关模块</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># math模块</span></span><br><span class="line"><span class="comment"># Decimal模块：小数模块</span></span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">Decimal(<span class="string">"0.01"</span>) + Decimal(<span class="string">"0.02"</span>)        <span class="comment"># 返回Decimal("0.03")</span></span><br><span class="line">decimal.getcontext().prec = <span class="number">4</span>            <span class="comment"># 设置全局精度为4 即小数点后边4位</span></span><br><span class="line"><span class="comment"># Fraction模块：分数模块</span></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line">x = Fraction(<span class="number">4</span>, <span class="number">6</span>)                       <span class="comment"># 分数类型 4/6</span></span><br><span class="line">x = Fraction(<span class="string">"0.25"</span>)                     <span class="comment"># 分数类型 1/4 接收字符串类型的参数</span></span><br></pre></td></tr></table></figure><h5><span id="9集合set">9.集合set</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">set是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。</span></span><br><span class="line"><span class="string">set支持union(联合),intersection(交),difference(差)和symmetric_difference(对称差集)数学运算。</span></span><br><span class="line"><span class="string">set支持x in set, len(set), for x in set。</span></span><br><span class="line"><span class="string">set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = set([<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>])                          <span class="comment"># 创建一个数值集合，返回&#123;3, 5, 9, 10&#125;</span></span><br><span class="line">t = set(<span class="string">"Hello"</span>)                             <span class="comment"># 创建一个唯一字符的集合返回&#123;&#125;</span></span><br><span class="line">a = t | s;    t.union(s)                     <span class="comment"># t 和 s的并集</span></span><br><span class="line">b = t &amp; s;    t.intersection(s)              <span class="comment"># t 和 s的交集</span></span><br><span class="line">c = t – s;    t.difference(s)                <span class="comment"># 求差集（项在t中, 但不在s中）</span></span><br><span class="line">d = t ^ s;    t.symmetric_difference(s)      <span class="comment"># 对称差集（项在t或s中, 但不会同时出现在二者中）</span></span><br><span class="line">t.add(<span class="string">'x'</span>);   t.remove(<span class="string">'H'</span>)                  <span class="comment"># 增加/删除一个item</span></span><br><span class="line">s.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])                         <span class="comment"># 利用[......]更新s集合</span></span><br><span class="line">x <span class="keyword">in</span> s,  x <span class="keyword">not</span> <span class="keyword">in</span> s                          <span class="comment"># 集合中是否存在某个值</span></span><br><span class="line">s.issubset(t);      s &lt;= t                   <span class="comment"># 测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line">s.issuperset(t);    s &gt;= t                   <span class="comment"># 测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line">s.copy();</span><br><span class="line">s.discard(x);                                <span class="comment"># 删除s中x</span></span><br><span class="line">s.clear()                                    <span class="comment"># 清空s</span></span><br><span class="line">&#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;                 <span class="comment"># 集合解析，结果：&#123;16, 1, 4, 9&#125;</span></span><br><span class="line">&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span>&#125;                          <span class="comment"># 集合解析，结果：&#123;'a', 'p', 's', 'm'&#125;</span></span><br></pre></td></tr></table></figure><h5><span id="10冻结集合frozenset">10.冻结集合frozenset</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list等(tuple是可以作为字典key的)</span></span><br><span class="line"><span class="string">frozenset是不可变对象，即存在hash值，可作为字典的键值</span></span><br><span class="line"><span class="string">frozenset对象没有add、remove等方法，但有union/intersection/difference等方法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = set()</span><br><span class="line">b.add(a)                     <span class="comment"># error: set是不可哈希类型</span></span><br><span class="line">b.add(frozenset(a))          <span class="comment"># ok，将set变为frozenset，可哈希</span></span><br></pre></td></tr></table></figure><h5><span id="11布尔类型bool">11.布尔类型bool</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="keyword">True</span>)                   <span class="comment"># 返回&lt;class 'bool'&gt;</span></span><br><span class="line">isinstance(<span class="keyword">False</span>, int)       <span class="comment"># bool类型属于整型，所以返回True</span></span><br><span class="line"><span class="keyword">True</span> == <span class="number">1</span>; <span class="keyword">True</span> <span class="keyword">is</span> <span class="number">1</span>         <span class="comment"># 输出(True, False)</span></span><br></pre></td></tr></table></figure><h5><span id="12动态类型简介">12.动态类型简介</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">变量名通过引用，指向对象。</span></span><br><span class="line"><span class="string">Python中的“类型”属于对象，而不是变量，每个对象都包含有头部信息，比如"类型标示符" "引用计数器"等</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！</span></span><br><span class="line"><span class="comment">#共享引用和相等测试：</span></span><br><span class="line">    L = [<span class="number">1</span>], M = [<span class="number">1</span>], L <span class="keyword">is</span> M            <span class="comment"># 返回False</span></span><br><span class="line">    L = M = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], L <span class="keyword">is</span> M           <span class="comment"># 返回True，共享引用</span></span><br><span class="line"><span class="comment">#增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+=会在原处修改</span></span><br><span class="line">    L = M = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    L = L + [<span class="number">3</span>, <span class="number">4</span>]                      <span class="comment"># L = [1, 2, 3, 4], M = [1, 2]</span></span><br><span class="line">    L += [<span class="number">3</span>, <span class="number">4</span>]                         <span class="comment"># L = [1, 2, 3, 4], M = [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h5><span id="13常见字符串常量和表达式">13.常见字符串常量和表达式</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">''</span>                                  <span class="comment"># 空字符串</span></span><br><span class="line">S = <span class="string">"spam’s"</span>                            <span class="comment"># 双引号和单引号相同</span></span><br><span class="line">S = <span class="string">"s\np\ta\x00m"</span>                      <span class="comment"># 转义字符</span></span><br><span class="line">S = <span class="string">"""spam"""</span>                          <span class="comment"># 三重引号字符串，一般用于函数说明</span></span><br><span class="line">S = <span class="string">r'\temp'</span>                            <span class="comment"># Raw字符串，不会进行转义，抑制转义</span></span><br><span class="line">S = <span class="string">b'Spam'</span>                             <span class="comment"># Python3中的字节字符串</span></span><br><span class="line">S = <span class="string">u'spam'</span>                             <span class="comment"># Python2.6中的Unicode字符串</span></span><br><span class="line">s1+s2, s1*<span class="number">3</span>, s[i], s[i:j], len(s)       <span class="comment"># 字符串操作</span></span><br><span class="line"><span class="string">'a %s parrot'</span> % <span class="string">'kind'</span>                  <span class="comment"># 字符串格式化表达式</span></span><br><span class="line"><span class="string">'a &#123;1&#125; &#123;0&#125; parrot'</span>.format(<span class="string">'kind'</span>, <span class="string">'red'</span>)<span class="comment"># 字符串格式化方法</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> s: print(x)                    <span class="comment"># 字符串迭代，成员关系</span></span><br><span class="line">[x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]                        <span class="comment"># 字符串列表解析</span></span><br><span class="line"><span class="string">','</span>.join([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])               <span class="comment"># 字符串输出，结果：a,b,c</span></span><br></pre></td></tr></table></figure><h5><span id="14内置str处理函数">14.内置str处理函数</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"stringobject"</span></span><br><span class="line"><span class="comment"># 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写</span></span><br><span class="line">str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title()        </span><br><span class="line">str1.ljust(width)                       <span class="comment"># 获取固定长度，左对齐，右边不够用空格补齐</span></span><br><span class="line">str1.rjust(width)                       <span class="comment"># 获取固定长度，右对齐，左边不够用空格补齐</span></span><br><span class="line">str1.center(width)                      <span class="comment"># 获取固定长度，中间对齐，两边不够用空格补齐</span></span><br><span class="line">str1.zfill(width)                       <span class="comment"># 获取固定长度，右对齐，左边不足用0补齐</span></span><br><span class="line">str1.find(<span class="string">'t'</span>,start,end)                <span class="comment"># 查找字符串，可以指定起始及结束位置搜索</span></span><br><span class="line">str1.rfind(<span class="string">'t'</span>)                         <span class="comment"># 从右边开始查找字符串</span></span><br><span class="line">str1.count(<span class="string">'t'</span>)                         <span class="comment"># 查找字符串出现的次数</span></span><br><span class="line"><span class="comment"># 上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1</span></span><br><span class="line"><span class="comment"># ---  --- #</span></span><br><span class="line"><span class="comment"># 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new</span></span><br><span class="line">str1.replace(<span class="string">'old'</span>,<span class="string">'new'</span>)               </span><br><span class="line">str1.strip();                           <span class="comment"># 默认删除空白符</span></span><br><span class="line">str1.strip(<span class="string">'d'</span>);                        <span class="comment"># 删除str1字符串中开头、结尾处，位于 d 删除序列的字符</span></span><br><span class="line">str1.lstrip();</span><br><span class="line">str1.lstrip(<span class="string">'d'</span>);                       <span class="comment"># 删除str1字符串中开头处，位于 d 删除序列的字符</span></span><br><span class="line">str1.rstrip();</span><br><span class="line">str1.rstrip(<span class="string">'d'</span>)                        <span class="comment"># 删除str1字符串中结尾处，位于 d 删除序列的字符</span></span><br><span class="line">str1.startswith(<span class="string">'start'</span>)                <span class="comment"># 是否以start开头</span></span><br><span class="line">str1.endswith(<span class="string">'end'</span>)                    <span class="comment"># 是否以end结尾</span></span><br><span class="line"><span class="comment"># 判断字符串是否全为字符、数字、小写、大写</span></span><br><span class="line">str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper()</span><br></pre></td></tr></table></figure><h5><span id="15字符串转换及另类拼接">15.字符串转换及另类拼接</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.转换</span></span><br><span class="line">int(<span class="string">'42'</span>), str(<span class="number">42</span>)                      <span class="comment"># 返回(42, '42')</span></span><br><span class="line">float(<span class="string">'4.13'</span>), str(<span class="number">4.13</span>)                <span class="comment"># 返回(4.13, '4.13')</span></span><br><span class="line">ord(<span class="string">'s'</span>), chr(<span class="number">115</span>)                      <span class="comment"># 返回(115, 's')</span></span><br><span class="line">int(<span class="string">'1001'</span>, <span class="number">2</span>)                          <span class="comment"># 将字符串作为二进制数字，转化为数字，返回9</span></span><br><span class="line"><span class="comment"># 将整数转化为二进制/八进制/十六进制字符串，返回('0b1101', '015', '0xd')</span></span><br><span class="line">bin(<span class="number">13</span>), oct(<span class="number">13</span>), hex(<span class="number">13</span>)</span><br><span class="line"><span class="comment"># 2.另类拼接</span></span><br><span class="line">name = <span class="string">"wang"</span> <span class="string">"wg"</span>                    <span class="comment"># 单行，name = "wangwg"</span></span><br><span class="line">name = <span class="string">"wang"</span> \</span><br><span class="line">        <span class="string">"wg"</span>                          <span class="comment"># 多行，name = "wangwg"</span></span><br></pre></td></tr></table></figure><h5><span id="16字符串格式化">16.字符串格式化</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 1.字符串格式化表达式 ###</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">基于C语言的'print'模型，并且在大多数的现有的语言中使用。</span></span><br><span class="line"><span class="string">通用结构：%[(name)][flag][width].[precision]typecode</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"this is %d %s bird"</span> % (<span class="number">1</span>, <span class="string">'dead'</span>)                   <span class="comment"># 一般的格式化表达式</span></span><br><span class="line"><span class="string">"%s---%s---%s"</span> % (<span class="number">42</span>, <span class="number">3.14</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])               <span class="comment"># 字符串输出：'42---3.14---[1, 2, 3]'</span></span><br><span class="line"><span class="comment"># 对齐方式及填充："1234...  1234...1234  ...001234"</span></span><br><span class="line"><span class="string">"%d...%6d...%-6d...%06d"</span> % (<span class="number">1234</span>, <span class="number">1234</span>, <span class="number">1234</span>, <span class="number">1234</span>)         </span><br><span class="line">x = <span class="number">1.23456789</span></span><br><span class="line"><span class="string">"%e | %f | %g"</span> % (x, x, x)                <span class="comment"># 对齐方式："1.234568e+00 | 1.234568 | 1.23457"</span></span><br><span class="line"><span class="string">"%6.2f*%-6.2f*%06.2f*%+6.2f"</span> % (x, x, x, x)     <span class="comment"># 对齐方式：'  1.23*1.23  *001.23* +1.23'</span></span><br><span class="line"><span class="string">"%(name1)d---%(name2)s"</span> % &#123;<span class="string">"name1"</span>:<span class="number">23</span>, <span class="string">"name2"</span>:<span class="string">"value2"</span>&#125;           <span class="comment"># 基于字典的格式化表达式</span></span><br><span class="line"><span class="string">"%(name)s is %(age)d"</span> % vars()    <span class="comment"># vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.字符串格式化调用方法 ###</span></span><br><span class="line"><span class="comment"># 普通调用</span></span><br><span class="line"><span class="string">"&#123;0&#125;, &#123;1&#125; and &#123;2&#125;"</span>.format(<span class="string">'spam'</span>, <span class="string">'ham'</span>, <span class="string">'eggs'</span>)            <span class="comment"># 基于位置的调用</span></span><br><span class="line"><span class="string">"&#123;motto&#125; and &#123;pork&#125;"</span>.format(motto = <span class="string">'spam'</span>, pork = <span class="string">'ham'</span>)   <span class="comment"># 基于Key的调用</span></span><br><span class="line"><span class="string">"&#123;motto&#125; and &#123;0&#125;"</span>.format(<span class="string">'ham'</span>, motto = <span class="string">'spam'</span>)             <span class="comment"># 混合调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加键 属性 偏移量 (import sys)</span></span><br><span class="line"><span class="comment"># 基于位置的键和属性</span></span><br><span class="line"><span class="string">"my &#123;1[spam]&#125; runs &#123;0.platform&#125;"</span>.format(sys, &#123;<span class="string">'spam'</span>:<span class="string">'laptop'</span>&#125;)</span><br><span class="line"><span class="comment"># 基于Key的键和属性</span></span><br><span class="line"><span class="string">"&#123;config[spam]&#125; &#123;sys.platform&#125;"</span>.format(sys = sys, config = &#123;<span class="string">'spam'</span>:<span class="string">'laptop'</span>&#125;)</span><br><span class="line"><span class="comment"># 基于位置的偏移量</span></span><br><span class="line"><span class="string">"first = &#123;0[0]&#125;, second = &#123;0[1]&#125;"</span>.format([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体格式化</span></span><br><span class="line"><span class="comment"># 输出'3.141590e+00, 3.142e+00, 3.14159'</span></span><br><span class="line"><span class="string">"&#123;0:e&#125;, &#123;1:.3e&#125;, &#123;2:g&#125;"</span>.format(<span class="number">3.14159</span>, <span class="number">3.14159</span>, <span class="number">3.14159</span>)</span><br><span class="line"><span class="string">"&#123;fieldname:format_spec&#125;"</span>.format(......)</span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    fieldname是指定参数的一个数字或关键字, 后边可跟可选的".name"或"[index]"成分引用</span></span><br><span class="line"><span class="string">    format_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type]</span></span><br><span class="line"><span class="string">    fill        ::=  &lt;any character&gt;              #填充字符</span></span><br><span class="line"><span class="string">    align       ::=  "&lt;" | "&gt;" | "=" | "^"        #对齐方式</span></span><br><span class="line"><span class="string">    sign        ::=  "+" | "-" | " "              #符号说明</span></span><br><span class="line"><span class="string">    width       ::=  integer                      #字符串宽度</span></span><br><span class="line"><span class="string">    precision   ::=  integer                      #浮点数精度</span></span><br><span class="line"><span class="string">    type        ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 例子:</span></span><br><span class="line">    <span class="string">'=&#123;0:10&#125; = &#123;1:10&#125;'</span>.format(<span class="string">'spam'</span>, <span class="number">123.456</span>)    <span class="comment"># 输出'=spam       =    123.456'</span></span><br><span class="line">    <span class="string">'=&#123;0:&gt;10&#125;='</span>.format(<span class="string">'test'</span>)                    <span class="comment"># 输出'=      test='</span></span><br><span class="line">    <span class="string">'=&#123;0:&lt;10&#125;='</span>.format(<span class="string">'test'</span>)                    <span class="comment"># 输出'=test      ='</span></span><br><span class="line">    <span class="string">'=&#123;0:^10&#125;='</span>.format(<span class="string">'test'</span>)                    <span class="comment"># 输出'=   test   ='</span></span><br><span class="line">    <span class="string">'&#123;0:X&#125;, &#123;1:o&#125;, &#123;2:b&#125;'</span>.format(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)   <span class="comment"># 输出'FF, 377, 11111111'</span></span><br><span class="line">    <span class="string">'My name is &#123;0:&#123;1&#125;&#125;.'</span>.format(<span class="string">'Fred'</span>, <span class="number">7</span>)       <span class="comment"># 输出'My name is Fred   .' 动态指定参数</span></span><br></pre></td></tr></table></figure><h5><span id="17索引和分片">17.索引和分片</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">0</span>], S[len(S)–<span class="number">1</span>], S[<span class="number">-1</span>]   <span class="comment"># 索引</span></span><br><span class="line"><span class="comment"># 分片，第三个参数指定步长，如S[1:10:2]是从1位到10位没隔2位获取一个字符。</span></span><br><span class="line">S[<span class="number">1</span>:<span class="number">3</span>], S[<span class="number">1</span>:], S[:<span class="number">-1</span>], S[<span class="number">1</span>:<span class="number">10</span>:<span class="number">2</span>]  <span class="comment"># list[begin:end:step]</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = []  <span class="comment"># 删除列表中1-4号元素后： a = [1, 5, 6, 7]</span></span><br><span class="line">b = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">del</span> b[::<span class="number">2</span>]   <span class="comment"># 去除偶数项(偶数索引的), b = [1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><h5><span id="18常用列表常量和操作">18.常用列表常量和操作</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">L = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">'string'</span>, &#123;&#125;]                        <span class="comment"># 嵌套列表</span></span><br><span class="line">L = list(<span class="string">'spam'</span>)                                  <span class="comment"># 列表初始化</span></span><br><span class="line">L = list(range(<span class="number">0</span>, <span class="number">4</span>))                             <span class="comment"># 列表初始化</span></span><br><span class="line">list(map(ord, <span class="string">'spam'</span>))                            <span class="comment"># 列表解析</span></span><br><span class="line">len(L)                                            <span class="comment"># 求列表长度</span></span><br><span class="line">L.count(value)                                    <span class="comment"># 求列表中某个值的个数</span></span><br><span class="line">L.append(obj)                          <span class="comment"># 向列表的尾部添加数据，比如append(2)，添加元素2</span></span><br><span class="line">L.insert(index, obj)                   <span class="comment"># 向列表的指定index位置添加数据，index及其之后的数据后移</span></span><br><span class="line"><span class="comment"># 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别</span></span><br><span class="line">L.extend(interable)                     </span><br><span class="line">L.index(value, [start, [stop]])        <span class="comment"># 返回列表中值value的第一个索引</span></span><br><span class="line">L.pop([index])                         <span class="comment"># 删除并返回index处的元素，默认为删除并返回最后一个元素</span></span><br><span class="line">L.remove(value)                        <span class="comment"># 删除列表中的value值，只删除第一次出现的value的值</span></span><br><span class="line">L.reverse()                                       <span class="comment"># 反转列表</span></span><br><span class="line">L.sort(cmp=<span class="keyword">None</span>, key=<span class="keyword">None</span>, reverse=<span class="keyword">False</span>)         <span class="comment"># 排序列表</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], b = a[<span class="number">10</span>:]              <span class="comment"># 注意，不会引发IndexError异常，只会返回一个空列表[]</span></span><br><span class="line">a = [], a += [<span class="number">1</span>]                       <span class="comment"># 这里实在原有列表的基础上进行操作，即列表的id没有改变</span></span><br><span class="line">a = [], a = a + [<span class="number">1</span>]                    <span class="comment"># 这里最后的a要构建一个新的列表，即a的id发生了变化</span></span><br></pre></td></tr></table></figure><h5><span id="19常用字典常量和操作">19.常用字典常量和操作</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D = &#123;&#125;</span><br><span class="line">D = &#123;<span class="string">'spam'</span>:<span class="number">2</span>, <span class="string">'tol'</span>:&#123;<span class="string">'ham'</span>:<span class="number">1</span>&#125;&#125;                   <span class="comment"># 嵌套字典</span></span><br><span class="line">D = dict.fromkeys([<span class="string">'s'</span>, <span class="string">'d'</span>], <span class="number">8</span>)                  <span class="comment"># &#123;'s': 8, 'd': 8&#125;</span></span><br><span class="line">D = dict(name = <span class="string">'tom'</span>, age = <span class="number">12</span>)                  <span class="comment"># &#123;'age': 12, 'name': 'tom'&#125;</span></span><br><span class="line">D = dict([(<span class="string">'name'</span>, <span class="string">'tom'</span>), (<span class="string">'age'</span>, <span class="number">12</span>)])          <span class="comment"># &#123;'age': 12, 'name': 'tom'&#125;</span></span><br><span class="line">D = dict(zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'tom'</span>, <span class="number">12</span>]))       <span class="comment"># &#123;'age': 12, 'name': 'tom'&#125;</span></span><br><span class="line">D.keys(); D.values(); D.items()                   <span class="comment"># 字典键、值以及键值对</span></span><br><span class="line">D.get(key, default)                               <span class="comment"># get函数</span></span><br><span class="line">D.update(D_other)   <span class="comment"># 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据</span></span><br><span class="line">D.pop(key, [D])   <span class="comment"># 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常</span></span><br><span class="line">D.popitem()                                       <span class="comment"># pop字典中随机的一项（一个键值对）</span></span><br><span class="line"><span class="comment"># 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。</span></span><br><span class="line">D.setdefault(k[, d])</span><br><span class="line"><span class="keyword">del</span> D                                             <span class="comment"># 删除字典</span></span><br><span class="line"><span class="keyword">del</span> D[<span class="string">'key'</span>]                                      <span class="comment"># 删除字典的某一项</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> D:   <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> D:                   <span class="comment"># 测试字典键是否存在</span></span><br><span class="line"><span class="comment"># 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象</span></span><br><span class="line"><span class="comment"># 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。</span></span><br><span class="line"><span class="comment"># 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象</span></span><br><span class="line">D[(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)] = <span class="number">2</span>                                    <span class="comment"># tuple作为字典的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典解析</span></span><br><span class="line">D = &#123;k:<span class="number">8</span> <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">'s'</span>, <span class="string">'d'</span>]&#125;                                <span class="comment"># &#123;'s': 8, 'd': 8&#125;</span></span><br><span class="line">D = &#123;k:v <span class="keyword">for</span> (k, v) <span class="keyword">in</span> zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'tom'</span>, <span class="number">12</span>])&#125;    <span class="comment"># &#123;'age': 12, 'name': tom&#125;</span></span><br></pre></td></tr></table></figure><h5><span id="20文件基本操作">20.文件基本操作</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">output = open(<span class="string">r'C:\spam'</span>, <span class="string">'w'</span>)          <span class="comment"># 打开输出文件，用于写</span></span><br><span class="line">input = open(<span class="string">'data'</span>, <span class="string">'r'</span>)               <span class="comment"># 打开输入文件，用于读。打开的方式可以为'w', 'r', 'a', 'wb', 'rb', 'ab'等</span></span><br><span class="line">fp.read([size])                         <span class="comment"># size为读取的长度，以byte为单位</span></span><br><span class="line">fp.readline([size])                     <span class="comment"># 读一行，如果定义了size，有可能返回的只是一行的一部分</span></span><br><span class="line">fp.readlines([size])                    <span class="comment"># 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。</span></span><br><span class="line">fp.readable()                           <span class="comment"># 是否可读</span></span><br><span class="line">fp.write(str)                           <span class="comment"># 把str写到文件中，write()并不会在str后加上一个换行符</span></span><br><span class="line">fp.writelines(seq)                      <span class="comment"># 把seq的内容全部写到文件中(多行一次性写入)</span></span><br><span class="line">fp.writeable()                          <span class="comment"># 是否可写</span></span><br><span class="line">fp.close()                              <span class="comment"># 关闭文件。</span></span><br><span class="line">fp.flush()                              <span class="comment"># 把缓冲区的内容写入硬盘</span></span><br><span class="line">fp.fileno()                             <span class="comment"># 返回一个长整型的”文件标签“</span></span><br><span class="line">fp.isatty()                             <span class="comment"># 文件是否是一个终端设备文件（unix系统中的）</span></span><br><span class="line">fp.tell()                               <span class="comment"># 返回文件操作标记的当前位置，以文件的开头为原点</span></span><br><span class="line">fp.next()                               <span class="comment"># 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</span></span><br><span class="line">fp.seek(offset[,whence])                <span class="comment"># 将文件打开操作标记移到offset的位置。whence为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。</span></span><br><span class="line">fp.seekable()                           <span class="comment"># 是否可以seek</span></span><br><span class="line">fp.truncate([size])                     <span class="comment"># 把文件裁成规定的大小，默认裁到当前文件操作标记的位置。</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'data'</span>):</span><br><span class="line">    print(line)                         <span class="comment"># 使用for语句，比较适用于打开比较大的文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    print(file.readline())              <span class="comment"># 使用with语句，可以保证文件关闭</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()            <span class="comment"># 一次读入文件所有行，并关闭文件</span></span><br><span class="line">open(<span class="string">'f.txt'</span>, encoding = <span class="string">'latin-1'</span>)     <span class="comment"># Python3.x Unicode文本文件</span></span><br><span class="line">open(<span class="string">'f.bin'</span>, <span class="string">'rb'</span>)                     <span class="comment"># Python3.x 二进制bytes文件</span></span><br><span class="line"><span class="comment"># 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等</span></span><br></pre></td></tr></table></figure><h5><span id="21其它">21.其它</span></h5><ul><li>Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真</li><li>通常意义下的类型分类： 1. 数字、序列、映射。 2. 可变类型和不可变类型</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/03/hello-world/"/>
      <url>/2018/12/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><a id="more"></a><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><!--more--><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
