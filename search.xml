<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>光圈、景深与虚化</title>
      <link href="/2020/08/08/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8-%E5%85%89%E5%9C%88-%E6%99%AF%E6%B7%B1-%E5%BF%AB%E9%97%A8/"/>
      <url>/2020/08/08/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8-%E5%85%89%E5%9C%88-%E6%99%AF%E6%B7%B1-%E5%BF%AB%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2><span id="概念">概念</span><a href="2020/08/08/摄影入门-光圈-景深-快门#undefined"></a></h2><h3><span id="光圈">光圈</span><a href="2020/08/08/摄影入门-光圈-景深-快门#undefined"></a></h3><p>光圈是镜头里用来控制镜头孔径大小的部件，它和快门协同工作控制进光</p><p>通常用 F 值来表示光圈大小，<strong>F 值小的是大光圈，F 值大的是小光圈</strong>。计算方式如下。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">光圈 F 值 = 镜头的焦距 / 光圈口径</span><br></pre></td></tr></table></div></figure><p>佳能 EOS-M50 微单为例首先设置模式为 Av 模式 (光圈优先) 。</p><p><img src="/images/camera/camera-button.jpeg" alt="相机按钮信息" class="article-img"></p><p>旋转光圈环按钮，可调整光圈 F 值。</p><h3><span id="景深">景深</span><a href="2020/08/08/摄影入门-光圈-景深-快门#undefined"></a></h3><p>相机在完成对焦以后（对焦：指的是拍照前，调整对焦点到相应的距离位置上，以使拍出来的照片清晰），其实不光焦点上的物体是清晰的，焦点前后一段距离内的物体也是清晰的。这个距离范围，就是 <strong>景深</strong>。</p><p>如，一枚 50mm 焦段的镜头，在光圈 F4 的情况下，拍摄距离我 1.5m 远的物体，把对焦点设置在 1.5m 上，但不仅仅正好在 1.5m 这个点上的物体是清晰的，在距离我 1.4m 到 1.6m 这个距离范围内的物体，也同样会是清晰的。而这 20cm 的距离范围，就是景深。</p><p><img src="/images/camera/光圈-景深.png" alt="相机按钮信息" class="article-img"></p><h3><span id="景深陷阱">景深陷阱</span><a href="2020/08/08/摄影入门-光圈-景深-快门#undefined"></a></h3><p>景深陷阱也叫陷阱对焦，指的是在手动对焦的情况下，提前预估被摄主体与相机之间的距离，利用镜头小光圈所带来的更大的景深范围，在被摄主体进入这个景深范围时，不需要再临时对焦，而直接进行拍摄。</p><p>如：一枚 28mm 的镜头，F16 的小光圈，把对焦点提前设置在距离我 1.5m 远的地方，由于 28mm 的镜头在光圈 F16 的时候，本身自带的景深范围是 0.8m-15m，也就是说，尽管焦点设置在了离我 1.5m 远的那个点上，但实际拍摄的时候，所有落在 0.8m-15m 这个距离范围内的物体都是清晰的，因此根本不用花时间让相机进行对焦。</p><h3><span id="光圈-景深与景深陷阱三者间的关系">光圈、景深与景深陷阱三者间的关系</span><a href="2020/08/08/摄影入门-光圈-景深-快门#undefined"></a></h3><ul><li>F 值越大，光圈越小，进光量越少，画面越暗，景深越大（画面越清晰）</li><li>F 值越小，光圈越大，进光量越多，画面越亮，景深越浅（背景会模糊）</li></ul><h3><span id="快门-曝光时间">快门、曝光时间</span><a href="2020/08/08/摄影入门-光圈-景深-快门#undefined"></a></h3><p>快门是相机里用来控制光线照射在感光元件上时间长短的装置，它挡在感光元件前面，它打开，感光元件才能被射进镜头里的光照到；它关上，就跟相机闭眼了差不多，感光元件就瞎了。换句话说，快门控制的就是曝光时间的长短。</p><ul><li>快门速度越快，曝光时间越短，画面越暗，越容易定格高速运动的物体</li><li>快门速度越慢，曝光时间越长，画面越亮，越方便记录物体的运动轨迹</li></ul>]]></content>
      
      
      <categories>
          
          <category> photo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄像 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 水平|垂直切分</title>
      <link href="/2020/03/01/MySQL%20%E6%B0%B4%E5%B9%B3%7C%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86/"/>
      <url>/2020/03/01/MySQL%20%E6%B0%B4%E5%B9%B3%7C%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>对于数据量比较大的表， 可以利用 MySQL 的水平切分或垂直切分的功能对数据表进行优化。</p><h2><span id="垂直切分">垂直切分</span><a href="2020/03/01/MySQL 水平|垂直切分#undefined"></a></h2><p>功能描述: 用户信息的数据库表( tb_user ) 由于保存的很多信息， 这个表需要有特别多的列( Column ) ， 我们可以把用户的一部分信息(比如：家庭地址 Address 等) ， 存入另一个表。这里当然要有一个相同的主键user_id连接两个表。这种方式也可称为：row spliting。</p><p>比较常用的垂直切分技术， 把一些变动较少的列放在一个表中( table 1 ) ， 然后把一些经常会变动的列放在另一个表中( table 2 ) ， 这样可以更高效的利用变动少的表( table 1 ) 中的查询缓存( Query cache ) ， 从而提升这部分数据的查询速度。</p><h2><span id="水平切分">水平切分</span><a href="2020/03/01/MySQL 水平|垂直切分#undefined"></a></h2><p>功能描述: 比如存在一个用来保存用户信息的数据库表( tb_user ) ， 利用水平切分就是将 user_id 在 1~100000 的用户保存在tb_user_0中， user_id在 100001~200000 的用户保存在 tb_user_1 中…等等以此类推。这里需要 tb_user_0、tb_user_1、tb_user_2… 数据表的结构保持完全一样。</p><p>比较常用的水平切分技术应用大致有两个方向。</p><ul><li>用来归档文件，将旧的数据放在一个表中，新的数据可以放到另一个表中。</li><li>分片(Sharding) ， 分片就是将不同的表放在不同的服务器上。即 tb_user_0 放在 server 0 上， tb_user_1 放在server 1 上等。水平切分的条件包括：RANGE、LIST、HASH、KEY等， 总的来说就是根据某个partion key(必须是整数) 来决定数据所在的分区。</li></ul><h3><span id="优势">优势</span><a href="2020/03/01/MySQL 水平|垂直切分#undefined"></a></h3><ul><li>MylSAM支持将表的多个部分存储于不同的文件系统或是磁盘， 可以存储更多数据；</li><li>提供直接删除一个 Partition 的语句， 速度较快；</li></ul><h3><span id="局限性">局限性</span><a href="2020/03/01/MySQL 水平|垂直切分#undefined"></a></h3><ul><li>innodb 不支持 directory 选择， partition后的表不能存储在多个路径中；</li><li>至少在 MySQL 5.5 之前没有对 partition 进行并行优化(如 sum()、count()、max () 等) ；</li><li>目前 MySQL 版本中还不支持多磁盘的并行 IO；</li></ul><h3><span id="案例">案例</span><a href="2020/03/01/MySQL 水平|垂直切分#undefined"></a></h3><p>针对数据量增长达到千万级的情况，做数据层面的优化处理。</p><p>主键 id 为自增， 我们的水平切分策略就是用该 id 作为切分依据， 使用 RANGE 模式进行水平切分。</p><p>根据 MySQL 的单表性能分析， 单表数据量在 500 万以下时， 基本上不会有影响， 所以本次水平切分的量级定义在 500 万。即每个分区最大存储 500 万条数据，超过 500 万条则保存到下一个分区表中。</p><p>创建分区的 SQL 语句如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`LOG_HISTORY_TABLE`</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">id</span>) <span class="keyword">PARTITIONS</span> <span class="number">5</span>(</span><br><span class="line">  <span class="keyword">PARTITION</span> part0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(<span class="number">5000000</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> part1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(<span class="number">10000000</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> part2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(<span class="number">15000000</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> part3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(<span class="number">20000000</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> part4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(MAXVALUE)</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>依据 id 切分的这种方案可能不够完美。深入业务沟通，尝试利用关键字段进行分表可能更加符合业务应用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试用例分层机制</title>
      <link href="/2020/02/25/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%88%86%E5%B1%82%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/02/25/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%88%86%E5%B1%82%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>测试用例分层机制的核心是将接口定义、测试步骤、测试用例、测试场景进行分离，单独进行描述和维护，从而尽可能地减少<code>自动化测试用例</code>的维护成本。</p><ul><li>测试用例（testcase）应该是完整且独立的，每条测试用例应该都是可以独立运行的</li><li>测试用例~/场景~是测试步骤（teststep）的<code>有序</code>集合，每一个测试步骤对于一个 API 接口的描述</li><li>测试组~/集~（testsuite）是测试用例的<code>无序</code>集合，集合中的测试用例应该都是相互独立，不存在前后依赖关系的；若确实存在先后依赖关系，可以在测试用例中完成依赖的处理，比如 <code>push case_pre</code> + <code>cur_case</code></li></ul><p><img src="/images/cases/测试用例方式.png" alt="测试用例格式" class="article-img"></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 命令使用场景及说明</title>
      <link href="/2020/02/17/git_bitbucket/"/>
      <url>/2020/02/17/git_bitbucket/</url>
      
        <content type="html"><![CDATA[<h2><span id="相关软件">相关软件</span><a href="2020/02/17/git_bitbucket#undefined"></a></h2><p><a href="https://git-scm.com" target="_blank" rel="noopener">Git</a> &nbsp; <a href="https://bitbucket.org" target="_blank" rel="noopener">Bitbucket</a> &nbsp; <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree</a></p><h2><span id="sourcetree-工具介绍">Sourcetree 工具介绍</span><a href="2020/02/17/git_bitbucket#undefined"></a></h2><p>介绍 Git 命令前，查阅一下 Sourcetree 主界面功能按钮。如下图。</p><ul><li><p>Sourcetree 主界面介绍</p><p> <img src="/images/git_bitbucket/03_Sourcetree_界面按钮.png" alt="Sourcetree 主界面功能" class="article-img"></p></li></ul><h2><span id="工作区与暂存区介绍">工作区与暂存区介绍</span><a href="2020/02/17/git_bitbucket#undefined"></a></h2><ol><li><p>工作区与暂存区</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本地仓库: git init初始化的文件夹</span><br><span class="line">&gt; 工作区: 当前文件夹(除隐藏目录外)</span><br><span class="line">&gt; 版本库: .git目录</span><br><span class="line">   &gt; 暂存区: stage或index文件夹</span><br><span class="line">   &gt; 分支: .git目录下master、develop、...</span><br><span class="line">   &gt; ...</span><br></pre></td></tr></table></div></figure><p><img src="/images/git_bitbucket/工作区与暂存区.png" alt="hello" class="article-img"></p></li></ol><h2><span id="git-命令介绍">Git 命令介绍</span><a href="2020/02/17/git_bitbucket#undefined"></a></h2><ol><li><a href="2020/02/17/git_bitbucket#git-init">创建仓库&gt; git init</a></li><li><a href="2020/02/17/git_bitbucket#git-clone">克隆仓库&gt; git clone</a></li><li><a href="2020/02/17/git_bitbucket#git-status">获取仓库文件状态&gt; git status</a></li><li><a href="2020/02/17/git_bitbucket#git-log">显示版本记录&gt; git log/reflog</a></li><li><a href="2020/02/17/git_bitbucket#git-add">增加文件&gt; git add</a></li><li><a href="2020/02/17/git_bitbucket#git-rm">删除文件&gt; git rm</a></li><li><a href="2020/02/17/git_bitbucket#git-mv">重命名文件&gt; git mv</a></li><li><a href="2020/02/17/git_bitbucket#git-commit">提交变更&gt; git commit</a></li><li><a href="2020/02/17/git_bitbucket#git-diff">版本比对&gt; git diff</a></li><li><a href="2020/02/17/git_bitbucket#git-reset">恢复版本&gt; git reset</a></li><li><a href="2020/02/17/git_bitbucket#git-stash">临时储存工作区&gt; git stash</a></li><li><a href="2020/02/17/git_bitbucket#git-tag">标签管理&gt; git tag</a></li><li><a href="2020/02/17/git_bitbucket#git-branch">创建/删除分支&gt; git branch</a></li><li><a href="2020/02/17/git_bitbucket#git-checkout">切换分支&gt; git checkout</a></li><li><a href="2020/02/17/git_bitbucket#git-merge">合并分支&gt; git merge</a></li><li><a href="2020/02/17/git_bitbucket#git-pull">拉取远程仓库分支最新版本&gt; git pull</a></li><li><a href="2020/02/17/git_bitbucket#git-push">推送到远程对应仓库分支&gt; git push</a></li><li><a href="2020/02/17/git_bitbucket#git-fix-conflict">常见问题：如何解决冲突</a></li><li><a href="2020/02/17/git_bitbucket#git-help">命令行文档&gt; git help</a></li></ol><h3><span id="创建仓库"><span id="git-init">创建仓库</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>创建仓库（版本库，以下都以仓库代替）有以下两种。<br>工作过程中，一般为第一种，由管理人员手动在 bitbucket 所在服务器中进行仓库创建并初始化。</p><ol><li><p>本地，仓库创建并初始化 [ x ]</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ mkdir git_bitbucket &amp;&amp; <span class="built_in">cd</span> git_bitbucket</span><br><span class="line">~$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/night/git_bitbucket/.git/</span><br></pre></td></tr></table></div></figure></li><li><p>远程服务器，仓库创建并初始化</p><p><img src="/images/git_bitbucket/01_仓库创建并初始化.png" alt="仓库创建并初始化" class="article-img"></p></li></ol><h3><span id="克隆仓库"><span id="git-clone">克隆仓库</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>克隆仓库指的是将服务器仓库映射到本地目录。方式有两种。</p><ol><li><p>使用命令行进行克隆</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone 命令说明</span></span><br><span class="line"><span class="comment"># git clone [源仓库地址] [本地目录]</span></span><br><span class="line">~$ git <span class="built_in">clone</span> https://wangwg@bitbucket.org/wangwg/git_bitbucket.git ~/git_bitbucket</span><br><span class="line">Cloning into <span class="string">'/Users/night/git_bitbucket'</span>...</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br></pre></td></tr></table></div></figure></li><li><p>bitbucket 网址仓库中使用 Sourcetree 进行克隆</p><p><img src="/images/git_bitbucket/02_sourcetree_clone.png" alt="使用 Sourcetree 克隆" class="article-img"></p></li></ol><h3><span id="获取仓库文件状态"><span id="git-status">获取仓库文件状态</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>获取当前工作区的所有变更。方式有两种。</p><ol><li><p>使用命令行查看文件变更</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></div></figure></li><li><p>使用 Sourcetree 界面查看文件变更</p><p><img src="/images/git_bitbucket/05_sourcetree_status.png" alt="使用 Sourcetree 查看变更" class="article-img"></p></li></ol><h3><span id="显示版本记录"><span id="git-log">显示版本记录</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>查看当前分支的版本记录。方式有两种。</p><ol><li><p>命令行方式当前分支的版本记录</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有两种命令均可查询当前分支的版本记录</span></span><br><span class="line"><span class="comment">#   * git log     [版本日志信息]</span></span><br><span class="line"><span class="comment">#   * git reflog  [简易版本日志信息]</span></span><br><span class="line">~$ git <span class="built_in">log</span></span><br><span class="line">commit d27ca7d0c8c54065ac0c7bef58c35b62744ff96b (HEAD -&gt; master)</span><br><span class="line">Author: xxx &lt;xxx@qq.com&gt;</span><br><span class="line">Date:   Fri Feb 14 17:52:22 2020 +0800</span><br><span class="line">   git commit</span><br><span class="line"></span><br><span class="line">commit 3c7c3fb9362f9f8df65567e6f9ecbeea0094c89b</span><br><span class="line">Author: xxx &lt;xxx@qq.com&gt;</span><br><span class="line">Date:   Fri Feb 14 17:23:25 2020 +0800</span><br><span class="line">   git add</span><br><span class="line"></span><br><span class="line">commit e7347a923aef9500112c970c91b24cf0fd05726c (origin/master, origin/HEAD)</span><br><span class="line">Author: xxx &lt;xxx@qq.com&gt;</span><br><span class="line">Date:   Thu Feb 13 09:59:24 2020 +0000</span><br><span class="line">   README.md created online with Bitbucket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~$ git reflog</span><br><span class="line">d27ca7d (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: git commit</span><br><span class="line">3c7c3fb HEAD@&#123;1&#125;: commit: git add</span><br><span class="line">e7347a9 (origin/master, origin/HEAD) HEAD@&#123;2&#125;: <span class="built_in">clone</span>: from https://wangwg@bitbucket.org/wangwg/git_bitbucket.git</span><br></pre></td></tr></table></div></figure></li><li><p>使用 sourcetree 进行当前分支的版本记录</p><p><img src="/images/git_bitbucket/08_sourcetree_log.png" alt="使用 Sourcetree 查看变更" class="article-img"></p></li></ol><h3><span id="增加文件"><span id="git-add">增加文件</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>Git 要求提交文件至新版本时，所有文件必须增加至暂存区。增加文件方式有两种</p><ol><li><p>命令行方式增加文件至暂存区</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git add 增加文件与 linux 创建文件的区别。（使用 git status 观察）</span></span><br><span class="line">~$ touch add_demo.txt</span><br><span class="line">~$ git status</span><br><span class="line">Untracked files:</span><br><span class="line">(use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">   add_demo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add 命令说明: 增加文件变更至暂存区，以备可以执行提交。</span></span><br><span class="line"><span class="comment">#   * git add file1 file2 ...  [按文件]</span></span><br><span class="line"><span class="comment">#   * git add .                [按目录]</span></span><br><span class="line"><span class="comment">#   * git add --A              [工作区所有文件变更]</span></span><br><span class="line"><span class="comment">#   * git add -u               [工作区所有上版本文件变更]</span></span><br><span class="line">~$ git add add_demo.txt</span><br><span class="line">~$ git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">   new file:   add_demo.txt</span><br></pre></td></tr></table></div></figure></li><li><p>使用 Sourcetree 界面增加文件, <strong>但是在点击 commit 按钮前执行 git add 操作。</strong></p><p><img src="/images/git_bitbucket/04_git_add.png" alt="使用 Sourcetree 增加文件" class="article-img"></p></li></ol><h3><span id="删除文件"><span id="git-rm">删除文件</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>“git rm file” 删除文件指的是删除当前版本库中的某个文件。而手动删除文件指的是删除本地工作区的文件，与 git 版本库暂存区无关。具体区别见示例。</p><ul><li><p>git rm 与 rm 的区别</p> <figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">~$ git status</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">~$ ls</span><br><span class="line">README.md    add_demo.txt</span><br><span class="line"><span class="comment"># 手动删除文件</span></span><br><span class="line">~$ rm -f add_demo.txt</span><br><span class="line">~$ git status</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">(use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">(use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">   deleted:    add_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">~$</span><br><span class="line"><span class="comment"># 删除版本库中文件</span></span><br><span class="line">~$ git rm -f add_demo.txt</span><br><span class="line">rm <span class="string">'add_demo.txt'</span></span><br><span class="line">~$ git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">   deleted:    add_demo.txt</span><br></pre></td></tr></table></div></figure></li></ul><h3><span id="重命名文件"><span id="git-mv">重命名文件</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>与 “git rm” 类似。 “git mv file” 指的是重命名当前版本库中的某个文件。而手动重命名文件指的是重命名本地工作区的文件，相当于在版本库中删除源文件再创建新文件。具体区别见示例。</p><ul><li><p>git mv 与 mv 的区别</p> <figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">~$ git status</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">~$ ls</span><br><span class="line">README.md    add_demo.txt</span><br><span class="line"><span class="comment"># 手动重命名文件</span></span><br><span class="line">~$ mv README.md README_mv.md</span><br><span class="line">~$ git status</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">(use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">(use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">   deleted:    README.md</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">(use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">   README_mv.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">~$</span><br><span class="line"><span class="comment"># 重命名版本库中文件</span></span><br><span class="line">~$ git mv README.md README_mv.md</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">   renamed:    README.md -&gt; README_mv.md</span><br></pre></td></tr></table></div></figure></li></ul><h3><span id="提交变更"><span id="git-commit">提交变更</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>“git commit” 提交暂存区中的文件变更，生成本地仓库新版本，版本号为 hash 值。本地提交方式有两种。</p><ol><li><p>命令行方式提交变更至本地仓库</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">~$ git status</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">(use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">(use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">   deleted:    README.md</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">(use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">   README_mv.md</span><br><span class="line"><span class="comment"># git 提交前需要增加文件变更至暂存区</span></span><br><span class="line">~$ git add .</span><br><span class="line">~$ git commit -m <span class="string">"test git commit"</span></span><br><span class="line">[master d27ca7d] git commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> rename README.md =&gt; README_mv.md (100%)</span><br><span class="line"><span class="comment"># 查看提交的版本，版本号为 hash 值 d27ca7d</span></span><br><span class="line">~$ git reflog | grep <span class="string">"test git commit"</span></span><br><span class="line">d27ca7d HEAD@&#123;0&#125;: commit: git commit</span><br></pre></td></tr></table></div></figure></li><li><p>使用 sourcetree 进行提交变更</p><p><img src="/images/git_bitbucket/06_sourcetree_commit.png" alt="使用 Sourcetree 进行提交变更" class="article-img"></p></li></ol><h3><span id="版本比对"><span id="git-diff">版本比对</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>“git diff” 命令作用是查看不同版本间的差异性。方式有使用命令行及 sourcetree 两种。</p><ol><li><p>使用命令行进行版本比对</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git diff 命令使用说明</span></span><br><span class="line"><span class="comment">#   * git diff                         [比较当前文件夹与当前 HEAD 版本所有文件的区别]</span></span><br><span class="line"><span class="comment">#   * git diff file                    [比较当前文件夹与当前 HEAD 版本的文件 file 的区别]</span></span><br><span class="line"><span class="comment">#   * git diff version1 version2       [比较版本 version1 和 2 中所有文件的区别]</span></span><br><span class="line"><span class="comment">#   * git diff file version1 version2  [比较版本 version1 和 2 中的文件 file 的区别]</span></span><br><span class="line">~$ git diff</span><br><span class="line">diff --git a/README_mv.md b/README_mv.md</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 39af52c..0000000</span><br><span class="line">--- a/README_mv.md</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,29 +0,0 @@</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">~$ git diff README_mv.md</span><br><span class="line">diff --git a/README_mv.md b/README_mv.md</span><br><span class="line">index 39af52c..498da56 100644</span><br><span class="line">--- a/README_mv.md</span><br><span class="line">+++ b/README_mv.md</span><br><span class="line">@@ -1,4 +1,5 @@</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">~$ git diff d27ca7d e7347a9</span><br><span class="line">diff --git a/README_mv.md b/README.md</span><br><span class="line">similarity index 100%</span><br><span class="line">rename from README_mv.md</span><br><span class="line">rename to README.md</span><br><span class="line">diff --git a/add_demo.txt b/add_demo.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index e69de29..0000000</span><br><span class="line"></span><br><span class="line">~$ git diff d27ca7d e7347a9 README.md</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 498da56..39af52c 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1,5 +1,4 @@</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure></li><li><p>使用 sourcetree 进行版本比对</p><p><img src="/images/git_bitbucket/07_sourcetree_diff.png" alt="使用 Sourcetree 进行版本比对" class="article-img"></p></li></ol><h3><span id="恢复版本"><span id="git-reset">恢复版本</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>恢复版本，或者说切换版本。方式有使用命令行及 sourcetree 两种。</p><ol><li><p>使用命令行进行版本切换</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~$ git reflog</span><br><span class="line">83ac3e1 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 0----</span><br><span class="line">d27ca7d HEAD@&#123;4&#125;: commit: git commit</span><br><span class="line">3c7c3fb HEAD@&#123;10&#125;: commit: git add</span><br><span class="line">e7347a9 (origin/master, origin/HEAD) HEAD@&#123;21&#125;: <span class="built_in">clone</span>: from https://wangwg@bitbu...</span><br><span class="line"><span class="comment"># 恢复版本至 git add 版本 [3c7c3fb]</span></span><br><span class="line"><span class="comment"># 简易用法如下：</span></span><br><span class="line">~$ git reset --hard 3c7c3fb</span><br><span class="line">HEAD is now at 3c7c3fb git add</span><br></pre></td></tr></table></div></figure></li><li><p>使用 sourcetree 进行版本切换</p><p><img src="/images/git_bitbucket/09_sourcetree_reset.png" alt="使用 Sourcetree 进行版本切换" class="article-img"></p></li></ol><h3><span id="临时储存工作区"><span id="git-stash">临时储存工作区</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>当工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该 bug。 </p><p>stash 临时储存工作区功能主要为了应急修复 bug，可以将当前工作现场“储藏”起来，等以后恢复现场后继续工作。常见场景如下：</p>   <figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前分支为 develop，正在工作中，假设修订文件 README.md</span></span><br><span class="line"><span class="comment"># 现在有一个 bug 需要在 master 分支上修复，此时做法如下：</span></span><br><span class="line"><span class="comment"># 1. 储藏当前工作区</span></span><br><span class="line">~$ git branch</span><br><span class="line">* develop</span><br><span class="line">  master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 储藏当前工作区</span></span><br><span class="line">~$ git stash save <span class="string">"save_cur_msg"</span></span><br><span class="line">~$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: save_cur_msg</span><br><span class="line"></span><br><span class="line"><span class="comment"># git stash show stash@&#123;n&#125;</span></span><br><span class="line"><span class="comment"># 显示第 n 个储藏区的变更内容，最后一个参数不写默认显示第一个</span></span><br><span class="line">~$ git stash show</span><br><span class="line">add_demo.txt | 1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 master, 拉取 bug 所在版本</span></span><br><span class="line">~$ git checkout master</span><br><span class="line">~$ git pull</span><br><span class="line"><span class="comment"># ... hack ... ... fix ...</span></span><br><span class="line">~$ git push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复 bug 后推送至远程，回到 develop 分支，继续工作</span></span><br><span class="line">~$ git checkout develop</span><br><span class="line"><span class="comment"># develop 环境是干净的</span></span><br><span class="line">~$ git status</span><br><span class="line">On branch develop</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"><span class="comment"># 恢复工作区</span></span><br><span class="line">~$ git stash pop</span><br><span class="line"><span class="comment"># ... hack ...</span></span><br></pre></td></tr></table></div></figure><h3><span id="标签管理"><span id="git-tag">标签管理</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>标签管理，依据提交的版本认为确认是否增加标签，需要填充标签信息。建议在 bitbucket 网页上 merge 之后手动增加符合格式要求的标签，尽量避免删除标签行为。</p><ul><li><p>本地标签管理方式两种如下。</p><ol><li><p>命令行</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地标签管理命令使用说明</span></span><br><span class="line"><span class="comment">#   * git tag                     [显示标签列表]</span></span><br><span class="line"><span class="comment">#   * git tag "tag_name"          [当前版本增加标签 "tag_name"]</span></span><br><span class="line"><span class="comment">#   * git tag "tag_info" version  [给 version 版本增加标签 "tag_name"]</span></span><br><span class="line"><span class="comment">#   * git tag -d "tag_name"       [删除标签 "tag_name"]</span></span><br><span class="line"><span class="comment">#   * git show "tag_name"         [查看标签 "tag_name" 信息]</span></span><br><span class="line">~$ git tag <span class="string">"tag_test_001_20200214"</span></span><br><span class="line">~$ git tag <span class="string">"old_label"</span> e7347a9</span><br><span class="line">~$ git tag</span><br><span class="line">old_label</span><br><span class="line">tag_test_001_20200214</span><br><span class="line">~$ git tag -d <span class="string">"tag_test_001_20200214"</span></span><br><span class="line">~$ git tag</span><br><span class="line">old_label</span><br><span class="line">~$ git show old_label</span><br><span class="line">commit e7347a923aef9500112c970c91b24cf0fd05726c (tag: old_label)</span><br><span class="line">Author: xxx &lt;xxx@qq.com&gt;</span><br><span class="line">Date:   Thu Feb 13 09:59:24 2020 +0000</span><br><span class="line">   README.md created online with Bitbucket</span><br><span class="line"></span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure></li><li><p>使用 sourcetree 标签管理</p><p><img src="/images/git_bitbucket/10_sourcetree_tag_add.png" alt="使用 Sourcetree 添加标签" class="article-img"><br><img src="/images/git_bitbucket/10_sourcetree_tag_list_del.png" alt="使用 Sourcetree 查看标签列表及删除标签" class="article-img"></p></li></ol></li><li><p>远程标签管理方式两种如下。</p><ol><li><p>命令行</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程相关标签管理命令使用说明</span></span><br><span class="line"><span class="comment">#   * git push origin &lt;tag_name&gt;  [推送标签 tag_name 至远程]</span></span><br><span class="line"><span class="comment">#   * git push origin --tags      [推送所有标签至远程]</span></span><br><span class="line"><span class="comment">#   删除远程标签 [先删除本地标签，再推送至远程。命令格式如下：]</span></span><br><span class="line"><span class="comment">#   * git tag -d &lt;tag_name&gt; &amp;&amp; git push origin :refs/tags/&lt;tag_name&gt;</span></span><br><span class="line">~$ git tag <span class="string">"remote_tag"</span></span><br><span class="line">~$ git push origin remote_tag</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://bitbucket.org/wangwg/git_bitbucket.git</span><br><span class="line">* [new tag]         remote_tag -&gt; remote_tag</span><br><span class="line"></span><br><span class="line">~$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://bitbucket.org/wangwg/git_bitbucket.git</span><br><span class="line">* [new tag]         old_label -&gt; old_label</span><br><span class="line"></span><br><span class="line">~$ git tag -d <span class="string">"old_label"</span> &amp;&amp; git push origin :refs/tags/old_label</span><br><span class="line">Deleted tag <span class="string">'old_label'</span> (was e7347a9)</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://bitbucket.org/wangwg/git_bitbucket.git</span><br><span class="line">- [deleted]         old_label</span><br></pre></td></tr></table></div></figure></li><li><p>远程 bitbucket 网页标签管理</p><p><img src="/images/git_bitbucket/11_bitbucket_add_tag.png" alt="使用 Sourcetree 查看标签列表及删除标签" class="article-img"></p></li></ol></li></ul><h3><span id="创建删除分支"><span id="git-branch">创建/删除分支</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>分支概念：分本地分支和远程分支。本地分支与远程分支要想同步，必须经过主动的拉去或推送。</p><p>仓库创建时，默认为 master 主分支，一般会增加 Develop 分支作为开发使用，feature 分支作为临时分支，以及 bug 分支作为临时 bug 修复分支。</p><p>创建分支，分本地创建及远程创建两种方式。</p><ol><li><p>本地创建分支，可分命令行及 Sourcetree 工具创建。示例分别如下：</p><ul><li><p>命令行创建及删除分支</p> <figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git branch 命令使用说明：</span></span><br><span class="line"><span class="comment">#   * git branch             [显示仓库分支列表]</span></span><br><span class="line"><span class="comment">#   * git branch develop     [创建分支 develop ]</span></span><br><span class="line"><span class="comment">#   * git branch -d develop  [删除分支 develop ]</span></span><br><span class="line">~$ git branch</span><br><span class="line">* master</span><br><span class="line"></span><br><span class="line">~$ git branch develop</span><br><span class="line">~$ git branch</span><br><span class="line">  develop</span><br><span class="line">* master</span><br><span class="line"></span><br><span class="line">~$ git branch -d develop</span><br><span class="line">Deleted branch develop (was 83ac3e1).</span><br><span class="line">~$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></div></figure></li><li><p>Sourcetree创建及删除分支</p><p> <img src="/images/git_bitbucket/12_sourcetree_create_branch.png" alt="使用 Sourcetree 创建分支" class="article-img"><br> <img src="/images/git_bitbucket/12_sourcetree_list_delete1_branch.png" alt="使用 Sourcetree 删除分支" class="article-img"><br> <img src="/images/git_bitbucket/12_sourcetree_list_delete2_branch.png" alt="使用 Sourcetree 删除分支" class="article-img"></p></li></ul></li><li><p>bitbucket 网址远程创建分支。</p><p><img src="/images/git_bitbucket/12_bitbucket_create_branch.png" alt="bitbucket 创建分支" class="article-img"><br><img src="/images/git_bitbucket/12_bitbucket_delete_branch.png" alt="bitbucket 创建分支" class="article-img"></p></li></ol><h3><span id="切换分支"><span id="git-checkout">切换分支</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>分支及分支切换的好处是： 你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><p>本地仓库切换分支方式有两种，远程仓库由管理人员操作及管理，此处不涉及。</p><ol><li><p>命令行</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换分支命令有两个， checkout 和 switch，为防止 git 版本陈旧，推荐使用 checkout 进行切换分支操作</span></span><br><span class="line"><span class="comment">#   * git checkout develop   [切换到 develop 分支]</span></span><br><span class="line"><span class="comment">#   * git switch -c develop  [同上, git version &gt;= 2.23]</span></span><br><span class="line">~$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/develop'</span>.</span><br></pre></td></tr></table></div></figure></li><li><p>sourcetree 工具</p><p><img src="/images/git_bitbucket/13_sourcetree_switch_branch.png" alt="使用 Sourcetree 切换分支" class="article-img"></p></li></ol><h3><span id="合并分支"><span id="git-merge">合并分支</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>合并分支，本地、远程皆可合并。但为了更好地协作工作，常见操作为，本地创建临时分支 feature，修订后，推送到 origin/feature， 在远程进行 pull request 后进行合并。</p><p>这里只介绍本地命令行合并及远程 bitbucket 网页上进行 pull request 后合并方式。</p><ol><li><p>本地命令行合并</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并分支 develop -&gt; master 基本流程如下：</span></span><br><span class="line"><span class="comment"># 0. 当前分支为 develop</span></span><br><span class="line">~$ git branch</span><br><span class="line">* develop</span><br><span class="line">  master</span><br><span class="line"><span class="comment"># 1. 操作 ...</span></span><br><span class="line">~$ vi add_demo.txt</span><br><span class="line"><span class="comment"># 2. 当前分支提交该变更</span></span><br><span class="line">~$ git add add_demo.txt</span><br><span class="line">~$ git commit -m <span class="string">"merge branch test"</span></span><br><span class="line">[develop 732919e] merge branch <span class="built_in">test</span></span><br><span class="line">1 file changed, 2 insertions(+)</span><br><span class="line"><span class="comment"># 3. 切换分支到 master</span></span><br><span class="line">~$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line"><span class="comment"># 4. 将 develop 的内容合并到当前分支 master</span></span><br><span class="line">~$ git merge develop</span><br><span class="line">Updating 83ac3e1..732919e</span><br><span class="line">Fast-forward</span><br><span class="line">add_demo.txt | 2 ++</span><br><span class="line">1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></div></figure></li><li><p>bitbucket pull request 后合并</p><ol><li>假设 develop 分支已提交变更并推送到远程 origin/develop</li><li>先进行请求 pr， 待相关人员进行 review 后，由仓库特定管理人员进行 merge。<br><img src="/images/git_bitbucket/14_bitbucket_pull_request.png" alt="bitbucket 发送请求"><br><img src="/images/git_bitbucket/14_bitbucket_merge_branch.png" alt="bitbucket 合并分支"></li></ol></li></ol><h3><span id="拉取远程仓库分支最新版本"><span id="git-pull">拉取远程仓库分支最新版本</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>当你从远程仓库克隆时，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且，远程仓库的默认名称是 origin 。</p><p>本地拉取远程仓库分支最新版本，方式分命令行和 sourcetree 工具拉取。此处不涉及冲突，后面单独介绍。</p><ol><li><p>命令行拉取远程分支版本</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git remote 查看远程库的信息</span></span><br><span class="line">~$ git remote -v</span><br><span class="line">origin  https://wangwg@bitbucket.org/wangwg/git_bitbucket.git (fetch)</span><br><span class="line">origin  https://wangwg@bitbucket.org/wangwg/git_bitbucket.git (push)</span><br><span class="line"><span class="comment"># 只拉取当前分支对应的远程分支， master &lt;- origin/master</span></span><br><span class="line"><span class="comment"># 当前分支 master 与远程 origin/master 不一致，拉取结果如下：</span></span><br><span class="line">~$ git pull</span><br><span class="line">Updating 3c7c3fb..83ac3e1</span><br><span class="line">Fast-forward</span><br><span class="line">README.md | 3 ++-</span><br><span class="line">1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></div></figure></li><li><p>sourcetree 工具拉取远程分支版本</p><p><img src="/images/git_bitbucket/15_sourcetree_pull_branch.png" alt="sourcetree 拉取分支" class="article-img"></p></li></ol><h3><span id="推送到远程对应仓库分支"><span id="git-push">推送到远程对应仓库分支</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>推送本地仓库分支到远程，与拉取类似。方式两种如下。</p><ol><li><p>命令行推送分支至远程仓库</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【前提】推送分支到远程是已与远程仓库进行了关联。</span></span><br><span class="line"><span class="comment"># 克隆仓库一般都会关联好本地仓库和远程仓库。但假设本地手动新建一个文件夹，想要关联远程的某一个仓库，此时可使用以下命令进行关联：</span></span><br><span class="line"><span class="comment">#    git remote add origin git@server-name:path/repo-name.git</span></span><br><span class="line"><span class="comment"># 手动关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只使用命令git push origin master 即可推送最新修改；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送分支命令格式如下：</span></span><br><span class="line"><span class="comment">#   git push origin &lt;branch&gt;  [推送分支 branch 至 origin/branch]</span></span><br><span class="line">~$ git push origin master</span><br><span class="line">Enumerating objects: 9, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (8/8), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (5/5), 578 bytes | 578.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 5 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://bitbucket.org/wangwg/git_bitbucket.git</span><br><span class="line">   83ac3e1..99e0ef9  master -&gt; master</span><br></pre></td></tr></table></div></figure></li><li><p>sourcetree 工具推送分支至远程仓库</p><p><img src="/images/git_bitbucket/16_sourcetree_push_branch.png" alt="sourcetree 推送分支" class="article-img"></p></li></ol><h3><span id="解决冲突"><span id="git-fix-conflict">解决冲突</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>冲突，指的是在你使用 “git push origin \&lt;branch>“ 推送分支版本到远程时，别人在你之前推送了一个版本。恰巧此时，你所修改的某一文件和他人修订内容不一致。此时需要解决该问题，简称为 “解决冲突”。</p><p>具体可参考以下案例：</p>   <figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前置条件： 当前刚从远程服务器克隆仓库 develop 分支</span></span><br><span class="line"><span class="comment"># 修改 add_demo.txt,尾行增加 “local add message”</span></span><br><span class="line">~$ vi add_demo.txt</span><br><span class="line">~$ git add . &amp;&amp; git commit -m <span class="string">"add local message"</span></span><br><span class="line"><span class="comment"># 此时，手动在 bitbucket 远程服务器上修改 add_demo.txt 文件，尾行增加 “remote add message”，模拟他人提交版本至远程 develop 分支</span></span><br><span class="line">~$ git push origin develop</span><br><span class="line">To https://bitbucket.org/wangwg/git_bitbucket.git</span><br><span class="line">! [rejected]        develop -&gt; develop (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'https://wangwg@bitbucket.org/wangwg/git_bitbucket.git'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错提示&gt;  hint: not have locally. This is usually caused by another repository pushing</span></span><br><span class="line"><span class="comment"># 此时拉取远程分支到本地，可察觉发生了 Auto-merging add_demo.txt， 但失败了。</span></span><br><span class="line">~$ git pull</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From https://bitbucket.org/wangwg/git_bitbucket</span><br><span class="line">   99e0ef9..96e69e9  develop    -&gt; origin/develop</span><br><span class="line">Auto-merging add_demo.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> add_demo.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"><span class="comment"># 此时，查看add_demo.txt</span></span><br><span class="line">~$ cat add_demo.txt</span><br><span class="line"></span><br><span class="line">hhhhhh</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">add <span class="built_in">local</span> message</span><br><span class="line">=======</span><br><span class="line">add remote message</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 96e69e94c07c7ebb665b22c8cf8d53646232ec05</span><br><span class="line"></span><br><span class="line"><span class="comment"># Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容</span></span><br><span class="line"><span class="comment"># 修改 add_demo.txt 文件内容为 “add local message after remote message” 后，提交变更再推送。</span></span><br><span class="line">~$ vi add_demo.txt</span><br><span class="line">~$ git add add_demo.txt &amp;&amp; git commit -m <span class="string">"fix-conflict"</span></span><br><span class="line">[develop da20742] fix-conflict</span><br><span class="line">~$ git push origin develop</span><br><span class="line">Enumerating objects: 10, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (10/10), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 607 bytes | 607.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote:</span><br><span class="line">remote: Create pull request <span class="keyword">for</span> develop:</span><br><span class="line">remote:   https://bitbucket.org/wangwg/git_bitbucket/pull-requests/new?<span class="built_in">source</span>=develop&amp;t=1</span><br><span class="line">remote:</span><br><span class="line">To https://bitbucket.org/wangwg/git_bitbucket.git</span><br><span class="line">   96e69e9..da20742  develop -&gt; develop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冲突解决</span></span><br></pre></td></tr></table></div></figure><h3><span id="命令行文档"><span id="git-help">命令行文档</span></span><a href="2020/02/17/git_bitbucket#undefined"></a></h3><p>git help 命令用来显示任何命令的 Git 自带文档。对于每一个命令的完整的可选项及标志列表，你可以随时运行 git help \&lt;command> 命令来了解。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">~$ git <span class="built_in">help</span></span><br><span class="line">usage: git [--version] [--<span class="built_in">help</span>] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">           [--<span class="built_in">exec</span>-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">           [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">           &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">These are common Git commands used <span class="keyword">in</span> various situations:</span><br><span class="line"></span><br><span class="line">start a working area (see also: git <span class="built_in">help</span> tutorial)</span><br><span class="line">   [+] <span class="built_in">clone</span>      Clone a repository into a new directory</span><br><span class="line">   [+] init       Create an empty Git repository or reinitialize an existing one</span><br><span class="line"></span><br><span class="line">work on the current change (see also: git <span class="built_in">help</span> everyday)</span><br><span class="line">   [+] add        Add file contents to the index</span><br><span class="line">   [+] mv         Move or rename a file, a directory, or a symlink</span><br><span class="line">   [+] reset      Reset current HEAD to the specified state</span><br><span class="line">   [+] rm         Remove files from the working tree and from the index</span><br><span class="line"></span><br><span class="line">examine the <span class="built_in">history</span> and state (see also: git <span class="built_in">help</span> revisions)</span><br><span class="line">   bisect     Use binary search to find the commit that introduced a bug</span><br><span class="line">   grep       Print lines matching a pattern</span><br><span class="line">   [+] <span class="built_in">log</span>        Show commit logs</span><br><span class="line">   show       Show various types of objects</span><br><span class="line">   [+] status     Show the working tree status</span><br><span class="line"></span><br><span class="line">grow, mark and tweak your common <span class="built_in">history</span></span><br><span class="line">   [+] branch     List, create, or delete branches</span><br><span class="line">   [+] checkout   Switch branches or restore working tree files</span><br><span class="line">   [+] commit     Record changes to the repository</span><br><span class="line">   [+] diff       Show changes between commits, commit and working tree, etc</span><br><span class="line">   [+] merge      Join two or more development histories together</span><br><span class="line">   rebase     Reapply commits on top of another base tip</span><br><span class="line">   [+] tag        Create, list, delete or verify a tag object signed with GPG</span><br><span class="line"></span><br><span class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</span><br><span class="line">   [+] fetch      Download objects and refs from another repository</span><br><span class="line">   [+] pull       Fetch from and integrate with another repository or a <span class="built_in">local</span> branch</span><br><span class="line">   [+] push       Update remote refs along with associated objects</span><br><span class="line"></span><br><span class="line"><span class="string">'git help -a'</span> and <span class="string">'git help -g'</span> list available subcommands and some</span><br><span class="line">concept guides. See <span class="string">'git help &lt;command&gt;'</span> or <span class="string">'git help &lt;concept&gt;'</span></span><br><span class="line">to <span class="built_in">read</span> about a specific subcommand or concept.</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>所谓成长</title>
      <link href="/2020/01/20/%E6%89%80%E8%B0%93%E6%88%90%E9%95%BF/"/>
      <url>/2020/01/20/%E6%89%80%E8%B0%93%E6%88%90%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h2><span id="25-年所谓成长">2.5 年所谓成长</span><a href="2020/01/20/所谓成长#undefined"></a></h2><p>时间恍然而过。等的人已杳无音信，还好梦想还是梦想，还在那。 ⚔︎</p><ul><li>2017.07.01 本科毕业</li><li>2017.07.06 入职</li><li>2020.01.20 在家（放假中）</li></ul><h2><span id="猪年已逝鼠年将至">猪年已逝，鼠年将至</span><a href="2020/01/20/所谓成长#undefined"></a></h2><p>Q1 - 30个月间，被讲的最多的话题。嗯，想想应该是 “<strong>你做了什么，不说出来有谁知道？独自抱怨只会让人瞧不起。</strong>”</p><p>Q2 - 被劝解最多的问题。“<strong>你脾气能不能收敛点，情商能不能不要表现的那么低？</strong>”</p><p>Q3 - 被调侃的最多的问题。”<strong>你为什么那么害羞？</strong>“</p><p>Q4 - 被询问最心虚的问题。”<strong>你代码能力如何而来，是本来就有，还是锻炼而出？</strong>“</p><p>Q5 - 被调侃最多的问题。“<strong>你有没有女朋友啊，需不需要我帮你介绍？</strong>”</p><p>Q6 - 很多很多 …</p><p>以上所有的问题，<strong>或真或假、或多或少都已有了答案，并付诸于行动</strong>。至于成效如何，自有他人判断。</p><p>愿鼠年对自己所做的事情欢喜感强烈一点。</p><p>生活、工作、娱乐顺着自己点。</p><h2><span id="收获或所谓成长">收获，或所谓成长</span><a href="2020/01/20/所谓成长#undefined"></a></h2><p>2020/01/20 10:10:xx，虹桥地铁站下车。</p><p>飞奔出站、上楼（爬楼梯+手扶电梯）、插队检票失败、失败、成功。非常感谢那个姑娘。安检、继续狂奔32B -&gt; 5B，2020/01/20 10:15:xx到了。</p><p>所幸，赶上了。2020/01/20 10:19:00发车。</p><p>过程中发现，自己腿脚疼痛、手臂酸软无力、呼吸不畅。是啊最先出问题的地方就是身体的短板。<strong>手臂、小腿、心脏承压</strong>，需要有意识的加强。<strong>木桶原理</strong>，最短的一块板子，是自己的瓶颈。</p><p>我是一名软件测试工程师。</p><p>在这里，我学了挺多东西， python、mysql、C、maven、linux/VxWorks ，还有就是自学的 go 。但好像，没有<strong>技术专精</strong>。给人就是表现平平，反响并未有多好。</p><p>==&gt; <strong>最长的一块板子，决定你能走多高、最短的一块板子，决定你能走多远。</strong></p><h2><span id="或深或浅">或深或浅</span><a href="2020/01/20/所谓成长#undefined"></a></h2><p>让我开心、让我不爽。谢谢你们。</p><ul><li>shiaq，温婉，哈～。想当老哥，旅途坎坷。</li><li>liuxf，暴躁、大大咧咧。诸多不愉快，我也好，你也罢。我那可笑的自尊心，唉。</li><li>wusz，沉稳，包容。</li><li>wangd，放飞自我。</li><li>…</li></ul><h2><span id="what-i-can">what i can</span><a href="2020/01/20/所谓成长#undefined"></a></h2><ul><li>测试设计能力</li><li>测试脚本编写能力</li><li>自动化测试能力</li><li>缺陷分析能力 + 代码排错能力</li><li>过程管控能力</li><li>工具: JIRA、Maven、Bamboo、Coverity、Git 等</li></ul><h2><span id="what-will-i-do">what will i do</span><a href="2020/01/20/所谓成长#undefined"></a></h2><ul><li>drf + react 构建 web 网站 / Go[maybe]</li><li>postman</li><li>算法</li><li><a href="https://zlinna.github.io/2019/12/28/2020" target="_blank" rel="noopener">2020-plan</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> myself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zlinna </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020</title>
      <link href="/2019/12/28/2020/"/>
      <url>/2019/12/28/2020/</url>
      
        <content type="html"><![CDATA[<p>技术栈扩充</p><ol><li>Robot Framework training - expand</li><li>postman training</li><li>fiddler、wireshark training</li><li>go、react training</li><li>python + redis training</li><li>python 仿 tf 实现 restful 接口测试框架 demo</li><li>MongoDB<a id="more"></a></li></ol><div class="article-bounded"><div class="article-table"><table><thead><tr><th>item</th><th>skill</th><th>no</th></tr></thead><tbody><tr><td>语言</td><td>Python、 C</td><td>Go、 React、 Shell(sed、awk)</td></tr><tr><td>数据库</td><td>mysql</td><td>MongoDB</td></tr><tr><td>自动化</td><td>-</td><td>Robot Framework、 testng、 unittest</td></tr><tr><td>接口测试工具</td><td>-</td><td>jmeter、 postman、 paw</td></tr><tr><td>UI自动化</td><td>TF</td><td>webUI(selenium)、 AppUI(Appium)</td></tr><tr><td>抓包工具</td><td>-</td><td>fiddler、 charles、 wireshark</td></tr><tr><td>缓存</td><td>-</td><td>memcache、 redis</td></tr><tr><td>异步事件</td><td>CN</td><td>rabbitmq、zeromq</td></tr><tr><td>日志分析</td><td>-</td><td>elk</td></tr></tbody></table></div></div>]]></content>
      
      
      <categories>
          
          <category> myself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zlinna </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试用例分类</title>
      <link href="/2019/12/14/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%88%86%E7%B1%BB/"/>
      <url>/2019/12/14/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2><span id="测试用例的-15-个分类">测试用例的 15 个分类</span><a href="2019/12/14/测试用例分类#undefined"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th>分类</th><th>说明</th><th>常见场景</th></tr></thead><tbody><tr><td>能力测试</td><td>确保程序的目标功能实现</td><td>可当作功能（接口层）测试。前置条件、输入项（…）、内部处理流程（…）、输出项（输出参数<br>、数据库/配置文件/全局变量更新、返回值、输出文件/报告、日志等）等</td></tr><tr><td>容量测试</td><td>发现处理大容量数据时的程序异常</td><td>如，数据表存储1w条时的插入、查找、删除效率等</td></tr><tr><td>强度测试</td><td>发现在大规模负载、高强度不间断持续的数据处理中的异常</td><td>如，内存已被占用 80% 以上，软件是否能正常运行、…等</td></tr><tr><td>可用性测试</td><td>评估最终用户在使用软件并与软件交互时的可用性问题</td><td>如，界面基本功能、所有按钮、异常恢复等</td></tr><tr><td>安全性测试</td><td>试图攻破程序的安全防线</td><td>如，多线程测试、异常测试(sql注入)、异常恢复等</td></tr><tr><td>性能测试</td><td>评估程序的响应时间以及吞吐量瓶颈等</td><td>根据性能指标及性能需求，针对性验证</td></tr><tr><td>存储测试</td><td>确保程序可以正确处理其对存储的需求，包括系统的存储和物理上的存储</td><td>如，文件打包机制、系统最大限制 fd 个数、文件存储磁盘最大限制等</td></tr><tr><td>配置测试</td><td>检查程序是否能在推荐配置上流畅运行</td><td>推荐或默认配置下运行正常，修改配置后，对应操作流程变更正确</td></tr><tr><td>兼容性/转换测试</td><td>评估新版本是否能兼容老的版本</td><td>如，兼容老版本测试、 OS 等</td></tr><tr><td>安装测试</td><td>确保能够在所有支持的平台上安装软件</td><td>如，linux、win、vxworks、centos等</td></tr><tr><td>可靠性测试</td><td>评估程序是否能达到规格说明书中的运行时长和 MTBF<br>（平均故障间隔时间）要求</td><td>根据需求定义的某功能项对应运行时长指标，进行针对性的可靠性测试，关注运行时长、MTBF、异常处理等</td></tr><tr><td>服务/可维护性测试</td><td>测试系统恢复相关的功能是否按设计要求实现</td><td>如，异常恢复、维护界面（软件恢复）等</td></tr><tr><td>文档测试</td><td>检验所有的用户文档是否正确</td><td>如，文档评审等</td></tr><tr><td>过程测试</td><td>对软件系统操作或维护所需涉及的流程进行评估和确定</td><td>如，文档评审、自测、冒烟测试等</td></tr></tbody></table></div></div><p>备注：分类来源于《软件测试的艺术》</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 的位运算</title>
      <link href="/2019/09/07/go%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2019/09/07/go%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2><span id="go-的位运算">Go 的位运算</span><a href="2019/09/07/go的位运算#undefined"></a></h2><p>在 Go 语言中支持以下几种操作位的方式：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 Go 语言中支持以下几种操作位的方式：</span></span><br><span class="line"><span class="comment">        &amp;   // 位与：仅当 a 和 b 都为 1 时，操作 a&amp;b 返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment">        |   // 位或：仅当 a 和 b 都为 0 时，操作 a|b 返回 0，否则返回 1。</span></span><br><span class="line"><span class="comment">        ^   // 异或：仅当 a!=b 时，操作 a^b 返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment">        &amp;^  // 位与非：仅当 a=1, b=0 时，操作 a&amp;^b 返回 1，否则返回 0。</span></span><br><span class="line"><span class="comment">        &lt;&lt;  // 左移：a &lt;&lt; n，将 a 中的所有位向左偏移 n 次, 右边用0补齐</span></span><br><span class="line"><span class="comment">        &gt;&gt;  // 右移：a &gt;&gt; n; 将 a 中的所有位向右偏移 n 次, 左边用0补齐</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></div></figure><p>详情见以下示例：<br><a id="more"></a><br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// &amp; 与( and )运算， 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当且仅当 a 和 b 都为 1 时，操作 a&amp;b 返回 1。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;b 为 0。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0xAC: 10101100</span></span><br><span class="line">    <span class="comment">// 0xF0: 11110000</span></span><br><span class="line">    num := <span class="number">0xAC</span> &amp; <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 10100000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// | 或( or )运算， 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当且仅当 a 和 b 都为 0 时，操作 a|b 返回 0。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;b 为 1。</span></span><br><span class="line">    num = <span class="number">0xAC</span> | <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 11111100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ^ 非、异或( xor )运算， 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当且仅当 a!=b 时，操作 a^b 返回 1。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;b 为 0。</span></span><br><span class="line">    num = <span class="number">0xAC</span> ^ <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 01011100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;^ 与非( and not )运算, 使用 &amp; 后，再使用 ^ 操作的简写</span></span><br><span class="line">    <span class="comment">// 给定 2 个操作数 a，b：</span></span><br><span class="line">    <span class="comment">// 当 a=1, b=0 时，操作 a&amp;^b 返回 1。</span></span><br><span class="line">    <span class="comment">// 否则操作 a&amp;^b 为 0。</span></span><br><span class="line">    num = <span class="number">0xAC</span> &amp;^ <span class="number">0xF0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num)  <span class="comment">// num: 00001100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt; 左移运算符</span></span><br><span class="line">    <span class="comment">// a &lt;&lt; n; 将 a 中的所有位向左偏移 n 次, 右边用0补齐</span></span><br><span class="line">    num2 := <span class="number">32</span> <span class="comment">// num2: 100000</span></span><br><span class="line">    num2 &lt;&lt;= <span class="number">2</span>  <span class="comment">// num2 = num2 &lt;&lt; 2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num2)  <span class="comment">// num: 10000000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; 右移运算符</span></span><br><span class="line">    <span class="comment">// a &gt;&gt; n; 将 a 中的所有位向右偏移 n 次, 左边用0补齐</span></span><br><span class="line">    num2 = <span class="number">32</span></span><br><span class="line">    num2 &gt;&gt;= <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, num2)  <span class="comment">// num: 001000</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wangwg</title>
      <link href="/2019/09/05/wangwg/"/>
      <url>/2019/09/05/wangwg/</url>
      
        <content type="html"><![CDATA[<p>Try again, please!</p>]]></content>
      
      
      <categories>
          
          <category> myself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zlinna </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ginkgo 测试框架使用入门</title>
      <link href="/2019/08/28/Ginkgo%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/08/28/Ginkgo%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1><span id="ginkgo-介绍">Ginkgo 介绍</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h1><p>Ginkgo是一个BDD风格的Go测试框架，旨在帮助您有效地编写富有表现力的综合测试。</p><h2><span id="安装及依赖">安装及依赖</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/onsi/ginkgo/ginkgo</span><br><span class="line">$ go get github.com/onsi/gomega/...</span><br></pre></td></tr></table></div></figure><p>在 $GOPATH 下使用上述命令安装 ginkgo 及匹配器 gomega。使用过程中遇到的问题：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Failed to compile 0344-reverse-string:</span><br><span class="line"></span><br><span class="line"><span class="comment"># leetcode/case/0344-reverse-string</span></span><br><span class="line">package leetcode/<span class="keyword">case</span>/0344-reverse-string_test</span><br><span class="line">        imports github.com/onsi/gomega</span><br><span class="line">        imports github.com/onsi/gomega/matchers</span><br><span class="line">        imports golang.org/x/net/html/charset</span><br><span class="line">        imports golang.org/x/text/encoding: cannot find package <span class="string">"golang.org/x/text/encoding"</span> <span class="keyword">in</span> any of:</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/golang.org/x/text/encoding (from <span class="variable">$GOROOT</span>)</span><br><span class="line">        /Users/night/go_learn/src/golang.org/x/text/encoding (from <span class="variable">$GOPATH</span>)</span><br></pre></td></tr></table></div></figure></p><p>问题为 text/encoding 包未找到，解决方案如下：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src</span><br><span class="line">$ mkdir golang.org/x/</span><br><span class="line">$ <span class="built_in">cd</span> golang.org/x</span><br><span class="line">$  git <span class="built_in">clone</span> https://github.com/golang/text.git text</span><br></pre></td></tr></table></div></figure></p><a id="more"></a><h2><span id="初步使用">初步使用</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>1、执行 <strong>ginkgo bootstrap</strong> ，生成 package_suite_test.go 模版文件，包含入口函数，例子如下。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo bootstrap                                 </span><br><span class="line">Generating ginkgo <span class="built_in">test</span> suite bootstrap <span class="keyword">for</span> problem0344 <span class="keyword">in</span>:</span><br><span class="line">        0344_reverse_string_suite_test.go</span><br><span class="line">$</span><br><span class="line">$ cat 0344_reverse_string_suite_test.go</span><br><span class="line">package problem0344_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">        . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">        . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Test0344ReverseString(t *testing.T) &#123;</span><br><span class="line">        RegisterFailHandler(Fail)</span><br><span class="line">        RunSpecs(t, <span class="string">"0344ReverseString Suite"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>2、执行 <strong>ginkgo generate xx</strong>（ xx 可不写，默认为当前文件夹名）是， 生成 xx_test.go ，例子如下。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo generate                         </span><br><span class="line">Generating ginkgo <span class="built_in">test</span> <span class="keyword">for</span> 0344ReverseString <span class="keyword">in</span>:</span><br><span class="line">  0344_reverse_string_test.go</span><br><span class="line">$</span><br><span class="line">$ cat 0344_reverse_string_test.go</span><br><span class="line">package problem0344_test</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">        . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line"></span><br><span class="line">        . <span class="string">"leetcode/case/0344-reverse-string"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var _ = Describe(<span class="string">"0344ReverseString"</span>, <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure></p><p>常规做法： package_suite_test.go 作为入口， xx_test.go 作为各个文件的测试源文件。</p><h2><span id="功能点">功能点</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>常用的模块及介绍如下表。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">模块</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">It</td><td style="text-align:left">It 包含的代码为一个测试用例</td></tr><tr><td style="text-align:left">Specify</td><td style="text-align:left">和 It 功能一致， 可作为别名在适当位置替换 It</td></tr><tr><td style="text-align:left">Describe</td><td style="text-align:left">将一个或多个测试用例归类</td></tr><tr><td style="text-align:left">Context</td><td style="text-align:left">同 Describe</td></tr><tr><td style="text-align:left">BeforeEach</td><td style="text-align:left">每个测试用例执行前执行该段代码</td></tr><tr><td style="text-align:left">AftreEach</td><td style="text-align:left">每个测试用例执行后执行该段代码</td></tr><tr><td style="text-align:left">JustBeforeEach</td><td style="text-align:left">在 BeforeEach 之后，执行测试用例之前执行</td></tr><tr><td style="text-align:left">JustAfterEach</td><td style="text-align:left">在执行测试用例之后，AftreEach之前执行</td></tr><tr><td style="text-align:left">BeforeSuite</td><td style="text-align:left">在该测试集执行前执行， package_suite_test.go 中 RunSpecs 执行之前</td></tr><tr><td style="text-align:left">AfterSuite</td><td style="text-align:left">无论是否有任何测试失败，该函数都会在测试集执行后运行</td></tr><tr><td style="text-align:left">By</td><td style="text-align:left">打印信息（字符串），只会在测试例失败后打印，一般用于调试和定位问题</td></tr><tr><td style="text-align:left">Fail</td><td style="text-align:left">标志该测试例运行结果为失败，并打印里面的信息</td></tr></tbody></table></div></div><p>通过实验得到以下顺序：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ginkgo <span class="comment">#or go test</span></span><br><span class="line">Running Suite: 0344ReverseString Suite</span><br><span class="line">======================================</span><br><span class="line">Random Seed: 1567008418</span><br><span class="line">Will run 1 of 1 specs</span><br><span class="line"></span><br><span class="line">BeforeSuite &gt; </span><br><span class="line">BeforeEach &gt; input =  zx</span><br><span class="line">JustBeforeEach &gt; append <span class="string">'l'</span> to input =  zxl</span><br><span class="line">Describe &gt; It &gt; After ReverseString input =  lxz</span><br><span class="line">JustAfterEach &gt; change input to =  I</span><br><span class="line">AfterEach &gt; input =  I</span><br><span class="line">•AfterSuite &gt; </span><br><span class="line"></span><br><span class="line">Ran 1 of 1 Specs <span class="keyword">in</span> 0.000 seconds</span><br><span class="line">SUCCESS! -- 1 Passed | 0 Failed | 0 Pending | 0 Skipped</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Ginkgo ran 1 suite <span class="keyword">in</span> 2.023695404s</span><br><span class="line">Test Suite Passed</span><br></pre></td></tr></table></div></figure></p><h2><span id="f-p-x-规范">F、P、X 规范</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>将容器（测试用例） Describe ， Context ， It ，和 Measure 标记为待定，通过添加 P 或者 X 即可。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PDescribe(<span class="string">"some behavior"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">PContext(<span class="string">"some scenario"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">PIt(<span class="string">"some assertion"</span>)</span><br><span class="line">PMeasure(<span class="string">"some measurement"</span>)</span><br><span class="line"></span><br><span class="line">XDescribe(<span class="string">"some behavior"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">XContext(<span class="string">"some scenario"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">XIt(<span class="string">"some assertion"</span>)</span><br><span class="line">XMeasure(<span class="string">"some measurement"</span>)</span><br></pre></td></tr></table></div></figure></p><p>跳过容器（测试用例），使用 skip 。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">It(<span class="string">"should do something, if it can"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !someCondition &#123;</span><br><span class="line">        Skip(<span class="string">"special condition wasn't met"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assertions go here</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure></p><p>F 含义 Focus ，使用后表专注于当前容器（测试用例）。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FDescribe(<span class="string">"some behavior"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">FContext(<span class="string">"some scenario"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line">FIt(<span class="string">"some assertion"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notice</span></span><br><span class="line">FDescribe(<span class="string">"outer describe"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    It(<span class="string">"A"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)   <span class="comment">// Not do</span></span><br><span class="line">    FIt(<span class="string">"B"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ... &#125;)  <span class="comment">// Do</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure></p><h2><span id="并行测试">并行测试</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>Ginkgo 支持并行运行规范。通过生成单独的 go test 进程并为共享队列中的每个进程提供规范来实现此目的。这对于 BDD 测试框架很重要，因为闭包的共享上下文不能在进程中很好地并行化。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ginkgo -p  <span class="comment">// 自动检测要生成的最佳测试节点数</span></span><br><span class="line">ginkgo -nodes=N  <span class="comment">// 使用 -nodes 指定要生成的节点数</span></span><br><span class="line">ginkgo -nodes=N -stream <span class="comment">// 设置 -stream 实时查看各个并行测试套件的输出</span></span><br></pre></td></tr></table></div></figure></p><h2><span id="表驱动测试">表驱动测试</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>包 github.com/onsi/ginkgo/extensions/table 提供表扩展功能，即根据每个 Entry 生成对应的 It（容器、测试用例）。使用方式如下：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> table_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo/extensions/table"</span></span><br><span class="line"></span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">    . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"Math"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    DescribeTable(<span class="string">"the &gt; inequality"</span>,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>, expected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">            Expect(x &gt; y).To(Equal(expected))</span><br><span class="line">        &#125;,</span><br><span class="line">        Entry(<span class="string">"x &gt; y"</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>),</span><br><span class="line">        Entry(<span class="string">"x == y"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>),</span><br><span class="line">        Entry(<span class="string">"x &lt; y"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure></p><p>其等同于的展开格式如下：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> table_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    . <span class="string">"github.com/onsi/ginkgo"</span></span><br><span class="line">    . <span class="string">"github.com/onsi/gomega"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = Describe(<span class="string">"Math"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Describe(<span class="string">"the &gt; inequality"</span>,</span><br><span class="line">        It(<span class="string">"x &gt; y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(<span class="number">1</span> &gt; <span class="number">0</span>).To(Equal(<span class="literal">true</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        It(<span class="string">"x == y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(<span class="number">0</span> &gt; <span class="number">0</span>).To(Equal(<span class="literal">false</span>))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        It(<span class="string">"x &lt; y"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Expect(<span class="number">0</span> &gt; <span class="number">1</span>).To(Equal(<span class="literal">false</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure></p><h2><span id="异步测试">异步测试</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>Go很好地兼容并发。Ginkgo为有效测试异步性提供支持。通过下面的例子进一步了解：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It(<span class="string">"should post to the channel, eventually"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> DoSomething(c)</span><br><span class="line">    Expect(&lt;-c).To(ContainSubstring(<span class="string">"Done!"</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure></p><p>此测试将阻塞，直到通道收到响应 c 。死锁或超时是这种测试的常见故障模式，在这种情况下，常见的模式是在函数的底部添加一个 select 语句，并包含一个 &lt;-time.After(X) 指定超时的通道。</p><p>Ginkgo 内置了这种模式。 body 所有非容器块（It s，BeforeEach es，AfterEach es，JustBeforeEach es，JustAfterEach es 和 Benchmark s）中的 done Done 函数都可以采用可选参数：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">It(<span class="string">"should post to the channel, eventually"</span>, <span class="function"><span class="keyword">func</span><span class="params">(done Done)</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> DoSomething(c)</span><br><span class="line">    Expect(&lt;-c).To(ContainSubstring(<span class="string">"Done!"</span>))</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">&#125;, <span class="number">0.2</span>)</span><br></pre></td></tr></table></div></figure></p><p>Done 是一个 chan interface{} 。当 Ginkgo 检测到 done Done 参数已被请求时，它将该 body 函数作为 goroutine 运行，并使用必要的逻辑将其包装以应用超时断言。您必须关闭done 通道，或向其发送一些内容（任何内容）以告知 Ginkgo 测试已结束。如果测试在超时期限后没有结束，那么 Ginkgo 将无法通过测试并继续进行下一次测试。</p><p>默认超时为 1 秒。您可以通过 float64 在 body 函数后面传递（以秒为单位）来修改此超时。在该示例中，我们将超时设置为 0.2 秒。</p><h2><span id="基准测试">基准测试</span><a href="2019/08/28/Ginkgo测试框架#undefined"></a></h2><p>Ginkgo 使用 Measure 块来衡量代码的性能。 Measure 作用于单个测试用例（It 的位置）。传递给的闭包函数 Measure 必须带 Benchmarker 参数。将 Benchmarker 用于测量的运行时间和记录任意的数值。还必须Measure在闭包函数后传递一个整数，这表示您的代码 Measure 将执行的次数。<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Measure(<span class="string">"it should do something hard efficiently"</span>, <span class="function"><span class="keyword">func</span><span class="params">(b Benchmarker)</span></span> &#123;</span><br><span class="line">    runtime := b.Time(<span class="string">"runtime"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        output := SomethingHard()</span><br><span class="line">        Expect(output).To(Equal(<span class="number">17</span>))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Ω(runtime.Seconds()).Should(BeNumerically(<span class="string">"&lt;"</span>, <span class="number">0.2</span>), <span class="string">"SomethingHard() shouldn't take too long."</span>)</span><br><span class="line"></span><br><span class="line">    b.RecordValue(<span class="string">"disk usage (in MB)"</span>, HowMuchDiskSpaceDidYouUse())</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br></pre></td></tr></table></div></figure></p><p>将运行闭包功能 10 次，聚合”运行时”和”磁盘使用”的数据。然后， ginkgo 打印执行的性能数据：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">• [MEASUREMENT]</span><br><span class="line">Suite</span><br><span class="line">    it should <span class="keyword">do</span> something hard efficiently</span><br><span class="line"></span><br><span class="line">    Ran 10 samples:</span><br><span class="line">    runtime:</span><br><span class="line">      Fastest Time: 0.01s</span><br><span class="line">      Slowest Time: 0.08s</span><br><span class="line">      Average Time: 0.05s ± 0.02s</span><br><span class="line"></span><br><span class="line">    disk usage (<span class="keyword">in</span> MB):</span><br><span class="line">      Smallest: 3.0</span><br><span class="line">       Largest: 5.2</span><br><span class="line">       Average: 3.9 ± 0.4</span><br></pre></td></tr></table></div></figure></p><p>Measures 可以在测试中与 It s 一起执行。如果你想只运行It s，你可以将 –skipMeasurements 标志传递给 ginkgo 。</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 测试框架 </tag>
            
            <tag> 测试实践 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试角度学习 groupcache</title>
      <link href="/2019/08/21/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0groupcache/"/>
      <url>/2019/08/21/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0groupcache/</url>
      
        <content type="html"><![CDATA[<h1><span id="groupcache-介绍">groupcache 介绍</span><a href="2019/08/21/测试角度学习groupcache#undefined"></a></h1><p>“groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.”。作者如是介绍该项目，翻译后的意思为：groupcache 是一个缓存和缓存填充库，在许多情况下用作 memcached 的替代品。</p><p>It is paused now..<br><a id="more"></a></p><h2><span id="测试角度学习-groupcache">测试角度学习 groupcache</span><a href="2019/08/21/测试角度学习groupcache#undefined"></a></h2><ul><li><strong>ring hash 算法</strong></li><li><strong>LRU 算法</strong></li><li><strong>singleflight 算法</strong></li><li>rpc</li><li>Protocol Buffers</li><li>groupcache 实现逻辑</li></ul><p>1、 consistenthash_test.go</p><p>2、 lru_test.go</p><p>3、 singleflight_test.go</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 测试实践 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试角度学习 cache2go</title>
      <link href="/2019/08/20/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0cache2go/"/>
      <url>/2019/08/20/%E6%B5%8B%E8%AF%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0cache2go/</url>
      
        <content type="html"><![CDATA[<h1><span id="cache2go-介绍">cache2go 介绍</span><a href="2019/08/20/测试角度学习cache2go#undefined"></a></h1><p>“Concurrency-safe golang caching library with expiration capabilities.”。作者如是介绍该项目，翻译后的意思为：存在心跳机制且并发安全的go语言缓存库。</p><h3><span id="tips">tips</span><a href="2019/08/20/测试角度学习cache2go#undefined"></a></h3><p>测试行为，而非实施。 “The public API of a package declare this is what(行为) I do, not this is <del>how(实施)</del> I do it.”</p><h3><span id="测试角度学习-cache2go">测试角度学习 cache2go</span><a href="2019/08/20/测试角度学习cache2go#undefined"></a></h3><p>我们知道心跳机制、并发安全是 cache2go 的两大特点，那么肯定是测试的重点了。 【Cachetable 简称 table，cacheitem 简称 item】</p><p>首先查看 cache_test.go ，可以获得以下信息：<br><a id="more"></a></p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>测试点</th><th>描述</th><th>具体因子</th></tr></thead><tbody><tr><td>TestCache</td><td>创建 table ，添加 item ，获取 item 基本信息</td><td>Cache, table.Add, table.Value, item.AccessCount, item.LifeSpan, item.AccessedOn、item.CreateOn</td></tr><tr><td>TestCacheExpire</td><td><strong>心跳机制</strong>：超出 lifeSpan 存活时间后自动消除 item</td><td>Cache, table.Add, table.Value</td></tr><tr><td>TestExists</td><td>table 表中是否存在 item</td><td>Cache, table.Add, <strong>table.Exists</strong></td></tr><tr><td>TestNotFoundAdd</td><td>table 表中是否存在 item ，若不存在则添加</td><td>Cache, table.Add, <strong>table.NotFoundAdd</strong></td></tr><tr><td>TestNotFoundAddConcurrency</td><td><strong>并发安全</strong>： NotFoundAdd</td><td>Cache, <strong>table.NotFoundAdd</strong>, <strong>table.Foreach</strong></td></tr><tr><td>TestCacheKeepAlive</td><td><strong>心跳机制</strong>： item 重新计时</td><td>Cache, table.Add, <strong>item.KeepAlive</strong>, table.Exists</td></tr><tr><td>TestDelete</td><td>从 table 表中删除 item</td><td>Cache, table.Add, table.Value, <strong>table.Delete</strong></td></tr><tr><td>TestFlush</td><td>清空 table 表所有 item</td><td>Cache, table.Add, <strong>table.Flush</strong>, table.Value</td></tr><tr><td>TestCount</td><td>table 表中 item 数量</td><td>Cache, table.Add, table.Value, <strong>table.Count</strong></td></tr><tr><td>TestDataLoader</td><td>访问不存在的 item 时会触发 loadData 回调函数</td><td>Cache, <strong>table.SetDataLoader</strong>, NewCacheItem, table.Value, table.Exists, item.Data</td></tr><tr><td>TestAccessCount</td><td>返回访问频率高的 count 条 item</td><td>Cache, table.Add, table.Value, <strong>table.MostAccessed</strong></td></tr><tr><td>TestCallbacks</td><td>增加、删除或超时移除情况下触发回调</td><td>Cache, <strong>table.SetAddItemCallback</strong>, <strong>table.SetAboutToDeleteItemCallback</strong>, <strong>item.SetAboutToExpireCallback</strong>, table.Add</td></tr><tr><td>TestCallbackQueue</td><td>设置、增加、清除 item 的回调函数正常</td><td>Cache, item.Key, table.Add, <strong>table.AddAddedItemCallback</strong>, <strong>table.AddAboutToDeleteItemCallback</strong>, <strong>item.AddAboutToExpireCallback</strong>, <strong>table.RemoveAddedItemCallbacks</strong>, <strong>table.RemoveAboutToDeleteItemCallback</strong>, <strong>item.SetAboutToExpireCallback</strong>, <strong>item.RemoveAboutToExpireCallback</strong></td></tr><tr><td>TestLogger</td><td>设置 logger 正常</td><td>Cache, <strong>table.SetLogger</strong>, table.Add</td></tr></tbody></table></div></div><p>再查看benchmark_test.go，可得：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>基准测试</th><th>具体因子</th><th>描述</th></tr></thead><tbody><tr><td>BenchmarkNotFoundAdd</td><td>基准测试： NotFoundAdd</td><td>Cache, <strong>table.NotFoundAdd</strong></td></tr></tbody></table></div></div>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 测试实践 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go Testing;How,What,Why</title>
      <link href="/2019/07/28/Go_Testing/"/>
      <url>/2019/07/28/Go_Testing/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span><a href="2019/07/28/Go_Testing#undefined"></a></h2><p>关于 Go 测试，我们应该知道测试方式（或者说测试手段）、测试对象及测试原因。</p><h2><span id="how-测试方式">How 测试方式</span><a href="2019/07/28/Go_Testing#undefined"></a></h2><h3><span id="测试实现">测试实现</span><a href="2019/07/28/Go_Testing#undefined"></a></h3><p>举个例子。针对字符串分割函数（如下），实现单元测试。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> goTest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">    i := strings.Index(s, sep)</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">        s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">        i = strings.Index(s, sep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在当前目录下且一样的包名 goTest ，写一个简单的 go 测试函数，如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> goTest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Split(<span class="string">"a/b/c"</span>, <span class="string">"/"</span>)</span><br><span class="line">    want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">        t.Fatalf(<span class="string">"expected: %v, got: %v"</span>, want, got)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>测试函数必须以 Test 开头， 且必须携带一个 *testing.T 参数。 t *testing.T 提供改测试函数的打印、跳过、失败功能。</p><h3><span id="测试执行">测试执行</span><a href="2019/07/28/Go_Testing#undefined"></a></h3><a id="more"></a><p>当前目录下，执行 go test ，输出如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      goTest  0.005s</span><br></pre></td></tr></table></div></figure><p>如果项目中存在多个 package ，若要执行所有包的测试可以在项目根目录下使用 go test ./… ，输出如下（例子：github.com/mattn/go-sqlite3）：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span> ./...</span><br><span class="line">ok      github.com/mattn/go-sqlite3 14.693s</span><br><span class="line">?       github.com/mattn/go-sqlite3/upgrade [no <span class="built_in">test</span> files]</span><br></pre></td></tr></table></div></figure><h3><span id="代码测试覆盖率">代码测试覆盖率</span><a href="2019/07/28/Go_Testing#undefined"></a></h3><p>还是以字符串分割函数为例， 获取当前代码测试覆盖率方式如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span> -coverprofile=c.out</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      goTest  0.005s</span><br></pre></td></tr></table></div></figure><p>数据显示覆盖率为 100% 。若要以 HTML 方式显示可以使用命令 <strong>go tool cover -html=c.out</strong> 。</p><p>【tip】 一行命令 cover 获取当前目录下的代码测试覆盖度。 在 ~/.bashrc 中添加如下命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cover</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> t=$(mktemp -t cover)</span><br><span class="line">    go <span class="built_in">test</span> <span class="variable">$COVERFLAGS</span> -coverprofile=<span class="variable">$t</span> <span class="variable">$@</span> \</span><br><span class="line">      &amp;&amp; go tool cover -func=<span class="variable">$t</span> \</span><br><span class="line">      &amp;&amp; unlink <span class="variable">$t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行后获取的测试覆盖度结果如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      goTest  0.008s</span><br><span class="line">goTest/wwg_split.go:7:  Split       100.0%</span><br><span class="line">total:             (statements)     100.0%</span><br></pre></td></tr></table></div></figure><p>问题：<strong>测试覆盖率 100% ，结束了？</strong></p><p>多个测试用例的情况下，使用表组测试用例装填。更改 TestSplit 如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep <span class="keyword">string</span></span><br><span class="line">        want []<span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,  <span class="comment">// trailing sep</span></span><br><span class="line">        &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        got := Split(tc.input, tc.sep)</span><br><span class="line">        <span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">            t.Fatalf(<span class="string">"expected: %v, got: %v"</span>, tc.want, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>增加测试用例 trailing sep 后，执行测试，结果如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    wwg_split_test.go:23: expected: [a b c], got: [a b c ]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    goTest0.005s</span><br></pre></td></tr></table></div></figure><p>根据该结果很难一下子在表组测试用例中查出是哪条。可以将 <strong>表组测试用例实现改为 map 形式</strong> ，具体如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;</span><br><span class="line">        input <span class="keyword">string</span></span><br><span class="line">        sep <span class="keyword">string</span></span><br><span class="line">        want []<span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="string">"simple"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"wrong sep"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">        <span class="string">"no sep"</span>: &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">t.Errorf(<span class="string">"%s expected: %v, got: %v"</span>, name, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行测试结果如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    wwg_split_test.go:23: trailing sep expected: [a b c], got: [a b c ]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAILgoTest0.005s</span><br></pre></td></tr></table></div></figure><p>Sub tests 使用，及 ‘%#v’ format 使用，更改 TestSplit 如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;</span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep <span class="keyword">string</span></span><br><span class="line">want []<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="string">"simple"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>: &#123;input: <span class="string">"a/b/c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a/b/c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"trailing sep"</span>: &#123;input: <span class="string">"a/b/c/"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"no sep"</span>: &#123;input: <span class="string">"abc"</span>, sep: <span class="string">"/"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;</span><br><span class="line">t.Fatalf(<span class="string">"%s expected: %#v, got: %#v"</span>, name, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>测试结果如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit/trailing_sep (0.00s)</span><br><span class="line">        wwg_split_test.go:24: trailing sep expected: []string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, got: []string&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">""</span>&#125;</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAILgoTest0.005s</span><br></pre></td></tr></table></div></figure><p>更好的打印格式，可以访问：</p><ul><li><a href="https://github.com/k0kubun/pp" target="_blank" rel="noopener">https://github.com/k0kubun/pp</a></li><li><a href="https://github.com/davecgh/go-spew" target="_blank" rel="noopener">https://github.com/davecgh/go-spew</a></li><li><a href="https://github.com/google/go-cmp" target="_blank" rel="noopener">https://github.com/google/go-cmp</a></li></ul><p>使用 google/go-cmp 优化打印， 更改 TestSplit 如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line">           diff := cmp.Diff(tc.want, got)</span><br><span class="line">           <span class="keyword">if</span> diff != <span class="string">""</span> &#123;</span><br><span class="line">               t.Fatalf(diff)</span><br><span class="line">           &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行测试结果如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit/trailing_sep (0.00s)</span><br><span class="line">        wwg_split_test.go:29:   []string&#123;</span><br><span class="line">              <span class="string">"a"</span>,</span><br><span class="line">              <span class="string">"b"</span>,</span><br><span class="line">              <span class="string">"c"</span>,</span><br><span class="line">            + <span class="string">""</span>,</span><br><span class="line">              &#125;</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAILgoTest0.005s</span><br></pre></td></tr></table></div></figure><p>修复bug后 Split 代码如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="built_in">len</span>(sep):]</span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result**</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行测试，结果如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  goTest0.006s</span><br><span class="line"></span><br><span class="line">&gt; cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok  goTest0.006s</span><br><span class="line">goTest/wwg_split.go:7:Split100.0%</span><br><span class="line">total:                  (statements)100.0%</span><br></pre></td></tr></table></div></figure><h2><span id="what-测试对象">What 测试对象</span><a href="2019/07/28/Go_Testing#undefined"></a></h2><p>Q_1：Go 应该测试所有因子吗？<br><br>A_1：显然不是。</p><p>Q_2：何时编写测试? 1.编码完成后？ 2.编码前？ 3.其他人遍写测试，像QA、TE？ 4.项目设计人员编写测试？<br><br>A_2：编码的同时编写测试代码（TDD）Article <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" target="_blank" rel="noopener">TheThreeRulesOfTdd</a></p><p>Q_3：C 单元测试对象是 function ，Java 单元测试对象是 Class ，类内部的方法， Go 的单元测试对象是？<br><br>A_3：package 。测试行为，而非实施。 “The public API of a package declare this is <strong>what</strong>(行为) I do, not this is <strong>how</strong>(实施) I do it.”</p><h2><span id="why-测试原因">Why 测试原因</span><a href="2019/07/28/Go_Testing#undefined"></a></h2><p>即使你不做代码测试，别人也会做。自己发现 issues 总比别人发现来得好，不是吗？<br></p><ol><li>大部分的测试(自动化)应该是开发人员自己做。</li><li>手工测试不应该是你测试的主体部分，因为手工测试的复杂度为O(n)</li><li>测试可以确保您始终可以运送主分支</li><li>测试确定软件行为（做什么、不做什么）</li><li>测试让你有信心修改他人的代码</li></ol><h2><span id="总结">总结</span><a href="2019/07/28/Go_Testing#undefined"></a></h2><ul><li>You should write tests.</li><li>You should write tests at the same time as you write your code.<br>Each Go package is a self contained unit.</li><li>Your tests should assert the observable behaviour of your package, not its implementation.</li><li>You should design your packages around their behaviour, not their implementation.</li></ul><p>【注】部分资料源于GopherChina 2019 - ‘How to write testable code’</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 使用及调优</title>
      <link href="/2019/05/20/MySQL%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%B0%83%E4%BC%98/"/>
      <url>/2019/05/20/MySQL%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2><span id="数据库使用-调优">数据库使用、调优</span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h2><ol><li><a href="2019/05/20/MySQL使用及调优#1">检索数据 select</a></li><li><a href="2019/05/20/MySQL使用及调优#2">排序数据 order by</a></li><li><a href="2019/05/20/MySQL使用及调优#3">过滤数据 where</a></li><li><a href="2019/05/20/MySQL使用及调优#4">数据过滤 where and / or / in / not in</a></li><li><a href="2019/05/20/MySQL使用及调优#5">模糊查询 like</a></li><li><a href="2019/05/20/MySQL使用及调优#6">正则匹配 regexp</a></li><li><a href="2019/05/20/MySQL使用及调优#7">创建计算字段 concat / trim</a></li><li><a href="2019/05/20/MySQL使用及调优#8">使用函数</a></li><li><a href="2019/05/20/MySQL使用及调优#9">分组/过滤 group by / having</a></li><li><a href="2019/05/20/MySQL使用及调优#10">使用子查询</a></li><li><a href="2019/05/20/MySQL使用及调优#11">联结表 join</a></li><li><a href="2019/05/20/MySQL使用及调优#12">组合查询 union</a></li><li><a href="2019/05/20/MySQL使用及调优#13">插入数据 insert</a></li><li><a href="2019/05/20/MySQL使用及调优#14">更新和删除数据 update/delete</a></li><li><a href="2019/05/20/MySQL使用及调优#15">创建和操作表 create/alter/references</a></li><li><a href="2019/05/20/MySQL使用及调优#16">使用视图 view</a></li><li><a href="2019/05/20/MySQL使用及调优#17">存储过程/游标/触发器/事务处理</a></li><li><a href="2019/05/20/MySQL使用及调优#18">全球化和本地化/安全管理/数据库维护</a></li><li><a href="2019/05/20/MySQL使用及调优#19">改善性能</a></li></ol><a id="more"></a><h3><span id="1-检索数据-select"><span id="1">1 检索数据 select</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products;  <span class="comment"># 检索单列</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products;  <span class="comment"># 检索多列</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> products;  <span class="comment"># 检索所有列</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> prod_id <span class="keyword">from</span> products;  <span class="comment"># 检索不同的行（去重）</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">limit</span> <span class="number">5</span>;  <span class="comment"># 检索单列的前5条记录</span></span><br><span class="line"><span class="keyword">select</span> products.prod_name <span class="keyword">from</span> products;  <span class="comment"># 使用限定表名检索单列</span></span><br></pre></td></tr></table></div></figure><h3><span id="2-排序数据-select-语句的-order-by-子句默认生序"><span id="2">2 排序数据 select 语句的 order by 子句（默认生序）</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检索单列并按 prod_name 字段进行排序</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"><span class="comment"># 检索多列，并按多列先后进行排序</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price, prod_name;</span><br><span class="line"><span class="comment"># 先按 prod_price 升序，再按 prod_name 降序</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price, prod_name <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment"># 先按 prod_price 降序，再按 prod_name 升序</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> prod_price <span class="keyword">desc</span>, prod_name;</span><br></pre></td></tr></table></div></figure><h3><span id="3-过滤数据-select-语句的-where-子句"><span id="3">3 过滤数据 select 语句的 where 子句</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查单个值</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> proc_name = <span class="string">"banana"</span>;</span><br><span class="line"><span class="comment"># 不匹配检查</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> proc_name != <span class="string">"banana"</span>;</span><br><span class="line"><span class="comment"># 范围值检查</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment"># 空值检查</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></div></figure><h3><span id="4-数据过滤-select-语句的-where-子句的andor-innot-in子句"><span id="4">4 数据过滤 select 语句的 where 子句的（and/or、in/not in）子句</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># and 操作符</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_id = <span class="number">1001</span> <span class="keyword">and</span> prod_price &lt;= <span class="number">10</span>;</span><br><span class="line"><span class="comment"># or 操作符</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_id = <span class="number">1001</span> <span class="keyword">or</span> prod_id = <span class="number">1002</span>;</span><br><span class="line"><span class="comment"># 计算次序问题（先计算 and ，在计算 or ）</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (prod_id = <span class="number">1001</span> <span class="keyword">or</span> prod_id = <span class="number">1002</span>) <span class="keyword">and</span> prod_price &lt;= <span class="number">10</span>;</span><br><span class="line"><span class="comment"># in 操作符</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_id <span class="keyword">in</span> (<span class="number">1001</span>, <span class="number">1002</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"><span class="comment"># not in 操作符</span></span><br><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1001</span>, <span class="number">1002</span>) <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br></pre></td></tr></table></div></figure><h3><span id="5-通配符过滤模糊查询select-语句的-where-子句的-like-子句"><span id="5">5 通配符过滤（模糊查询）select 语句的 where 子句的 like 子句</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尽量不使用模糊查询</span></span><br><span class="line"><span class="comment"># % 通配符，匹配任意次数(包括 0 次)</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">"bana%"</span></span><br><span class="line"><span class="comment"># _ 通配符，匹配单次</span></span><br><span class="line"><span class="keyword">select</span> prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">"_anan_"</span></span><br></pre></td></tr></table></div></figure><h3><span id="6-正则匹配-select-语句的-where-子句的-regexp-子句"><span id="6">6 正则匹配 select 语句的 where 子句的 regexp 子句</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'\\([0-9] sticks?\\)'</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name;</span><br><span class="line"><span class="comment"># prod_name</span></span><br><span class="line"><span class="comment"># TNT (1 stick</span></span><br><span class="line"><span class="comment"># TNT (5 sticks)</span></span><br></pre></td></tr></table></div></figure><h3><span id="7-创建计算字段-concattrim"><span id="7">7 创建计算字段 concat/trim</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建拼接字段 concat</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(vend_name, <span class="string">' ('</span>,vend_country, <span class="string">')'</span>) <span class="keyword">from</span> venders <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br><span class="line"><span class="comment"># 使用别名 as</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(vend_name, <span class="string">' ('</span>,vend_country, <span class="string">')'</span>) <span class="keyword">as</span> vend_info <span class="keyword">from</span> venders <span class="keyword">order</span> <span class="keyword">by</span> vend_name;</span><br><span class="line"><span class="comment"># 去除空格 trim/ltrim/rtrim</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">rtrim</span>(vend_name), <span class="string">' ('</span>,vend_country, <span class="string">')'</span>) <span class="keyword">from</span> venders;</span><br><span class="line"><span class="comment"># 执行算数计算 + - * /</span></span><br><span class="line"><span class="keyword">select</span> item_price, quantity, item_price*quantity <span class="keyword">as</span> expanded_price <span class="keyword">from</span> items;</span><br></pre></td></tr></table></div></figure><h3><span id="8-使用数据处理汇总函数"><span id="8">8 使用数据处理/汇总函数</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trim 函数</span></span><br><span class="line"><span class="comment"># upper/lower/length</span></span><br><span class="line"><span class="comment"># date/now</span></span><br><span class="line"><span class="comment"># abs/mod/rand/sin/cos/tan/sqrt</span></span><br><span class="line"><span class="comment"># count/avg/max/min/sum</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></div></figure><h3><span id="9-分组数据-select-语句的-group-by-having-子句"><span id="9">9 分组数据 select 语句的 group by / having 子句</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># group by 分组</span></span><br><span class="line"><span class="keyword">select</span> vent_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vent_id;</span><br><span class="line"><span class="comment"># vent_id | num_prods</span></span><br><span class="line"><span class="comment"># 1002    | 3</span></span><br><span class="line"><span class="comment"># 1003    | 7</span></span><br><span class="line"><span class="comment"># 1004    | 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># having 过滤</span></span><br><span class="line"><span class="keyword">select</span> vent_id, <span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vent_id <span class="keyword">having</span> vent_id &lt;= <span class="number">2</span>;</span><br><span class="line"><span class="comment"># vent_id | num_prods</span></span><br><span class="line"><span class="comment"># 1004    | 2</span></span><br></pre></td></tr></table></div></figure><h3><span id="10-使用子查询-select-语句的-select-子句"><span id="10">10 使用子查询 select 语句的 select 子句</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> proc_id = <span class="number">1002</span>)</span><br></pre></td></tr></table></div></figure><h3><span id="11-联结表-join"><span id="11">11 联结表 join</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><ul><li>inner join  两表交集</li><li>left join  左表（若左右表相同，去重，添加剩余的左表数据）</li><li>right join  右表</li><li>where 多表连结</li><li>left outer join</li><li>right outer join</li><li>full outer join</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">inner</span> <span class="keyword">join</span> items <span class="keyword">on</span> products.prod_name = items.prod_name;</span><br></pre></td></tr></table></div></figure><h3><span id="12-组合查询-union"><span id="12">12 组合查询 union</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><ul><li>多条查询语句的字段要一致</li><li>union 去重</li><li>union all 不去重</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_id &lt;= <span class="number">10000</span> <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price &lt;= <span class="number">100</span>;</span><br></pre></td></tr></table></div></figure><h3><span id="13-插入数据-insert"><span id="13">13 插入数据 insert</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入完整的行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> products <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">"apple"</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment"># 插入行的一部分</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> products(prod_name, prod_price) <span class="keyword">values</span>(<span class="string">"egg"</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="comment"># 插入多行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> products <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">"apple"</span>, <span class="number">9</span>),(<span class="number">4</span>, <span class="string">"egg"</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="comment"># 插入某些查询的结果</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> products(prod_id, prod_name, prod_price) <span class="keyword">select</span> prod_id, prod_name, prod_price <span class="keyword">from</span> products;</span><br></pre></td></tr></table></div></figure><h3><span id="14-更新和删除数据-updatedelete"><span id="14">14 更新和删除数据 update/delete</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> products <span class="keyword">set</span> prod_name = <span class="string">"apple_banana"</span> <span class="keyword">where</span> prod_id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> products <span class="keyword">set</span> prod_name = <span class="string">"apple_banana"</span>, prod_price = <span class="number">10</span> <span class="keyword">where</span> prod_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> products <span class="keyword">where</span> prod_id = <span class="number">1</span>;</span><br></pre></td></tr></table></div></figure><h3><span id="15-创建和操作表-createalterreferences"><span id="15">15 创建和操作表 create/alter/references</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> products (</span><br><span class="line">    prod_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    prod_name <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    prod_price <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">10</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (prod_id)</span><br><span class="line">    <span class="comment"># primary key (prod_id, prod_name)  # 组合是唯一的</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment"># )ENGINE=MyISAM;  # 不支持事务操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> products <span class="keyword">add</span> prod_number <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> products <span class="keyword">drop</span> colume prod_number;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名表</span></span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> products <span class="keyword">to</span> products_new;</span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> products <span class="keyword">to</span> products_new, items <span class="keyword">to</span> items_new;</span><br></pre></td></tr></table></div></figure><h3><span id="16-使用视图-view"><span id="16">16 使用视图 view</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><ol><li>视图用CREATE VIEW语句来创建</li><li>使用SHOW CREATE VIEW viewname;来查看创建视图的语句</li><li>用DROP删除视图，其语法为DROP VIEW viewname;</li><li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创 建一个视图;如果要更新的视图存在，则第2条更新语句会替换原 有视图</li></ol><h3><span id="17-存储过程游标触发器事务处理"><span id="17">17 存储过程/游标/触发器/事务处理</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><ul><li>使用存储过程 procedure</li><li>使用游标</li><li>使用触发器</li><li>事务处理</li></ul><h3><span id="18-全球化和本地化安全管理数据库维护"><span id="18">18 全球化和本地化/安全管理/数据库维护</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><ul><li>全球化和本地化</li><li>安全管理</li><li>数据库维护</li></ul><h3><span id="19-改善性能"><span id="19">19 改善性能</span></span><a href="2019/05/20/MySQL使用及调优#undefined"></a></h3><ol><li>SHOW VARIABLES; SHOW STATUS;  # 查看默认配置，是否需要修改配置</li><li>SHOW PROCESSLIST;  # 查看所有活动进程（线程 ID /运行时间）</li><li>总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、子查询等，找出最佳的方法</li><li>使用 EXPLAIN 语句让 MySQL 解释它将如何执行一条 SELECT 语句</li><li>存储过程执行得比一条一条地执行其中的各条 MySQL 语句快</li><li>应该总是使用正确的数据类型</li><li>决不要检索比需求还要多的数据。换言之，不要用 SELECT * (除非你真正需要每个列)</li><li>必须索引数据库表以改善数据检索的性能，是否索引根据数据表是查询多还是修改多</li><li>select 语句的 or 子句 ===&gt; 修订为 多条 select 和 union</li><li>LIKE 很慢。一般来说，最好是使用 FULLTEXT 而不是 LIKE</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ 指针</title>
      <link href="/2019/05/13/%E6%8C%87%E9%92%88_C++/"/>
      <url>/2019/05/13/%E6%8C%87%E9%92%88_C++/</url>
      
        <content type="html"><![CDATA[<h2><span id="指针">指针</span><a href="2019/05/13/指针_C++#undefined"></a></h2><p>指针是一个变量，其存储的是值的地址，而不是值本身。 值的地址，只需对变量应用地址运算符(&amp;)，即可得到其地址；例如home是一个变量，则&amp;home是它的地址。   *运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址存储的值。例如L: mainly是一个指针，则mainly是一个地址，*mainly表示存储在该地址处的值。</p><h4><span id="1声明指针">1.声明指针</span><a href="2019/05/13/指针_C++#undefined"></a></h4><p>要声明指向特定类型的指针，请使用下面的格式：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeName * pointerName;  <span class="comment">// 示例： double * pn;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针声明的格式。传统上C程序员使用该格式：</span></span><br><span class="line"><span class="keyword">int</span> *ptr;  <span class="comment">// 强调 *ptr 是一个int类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而C++大多数使用下述格式：</span></span><br><span class="line"><span class="keyword">int</span>* ptr;  <span class="comment">// 强调 int* 是一种类型 -- 指向int的指针</span></span><br></pre></td></tr></table></div></figure></p><p>其实，对于编译器来说空格所处位置没有区别，甚至可以不加空格，直接： int*ptr； 但是要知道的是，声明多个指针时，对每个指针变量名，都需要使用一个* 。</p><a id="more"></a><h4><span id="2给指针赋值">2.给指针赋值</span><a href="2019/05/13/指针_C++#undefined"></a></h4><p>应将内存地址赋给指针。可以对变量名应用&amp;运算符，来获得被命名的内存地址，new运算符返回未命名的内存地址。示例：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;  <span class="comment">// 将higgens地址赋给pt</span></span><br><span class="line"></span><br><span class="line">pc = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">pa = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br></pre></td></tr></table></div></figure></p><h4><span id="3对指针解除引用">3.对指针解除引用</span><a href="2019/05/13/指针_C++#undefined"></a></h4><p>对指针解除引用意味着获得指针指向的值。一种是对指针应用解除引用或间接值运算符(*)来解除引用。另一种是使用数组表示法，例如，pn[0]与(*p)是一样的。</p><h4><span id="4指针-数组和指针算术">4.指针、数组和指针算术</span><a href="2019/05/13/指针_C++#undefined"></a></h4><p>指针与数组基本等价的原因在于指针算数(pointer arithmetic)和C++内部处理数组的方式。先看看算数，将整数变量加1后，其值增加1；但将指针变量加1后，增加的量等于它指向的<strong>类型的字节数</strong>。 通常，使用数组表示法时，C++都执行下面的转换：arrayname[i] ==&gt; *(arrayname + i); 如果使用的是指针，而不是数组名，C++也执行同样的转换：pointername[i] ==&gt;*(pointername + i);</p><h4><span id="5指针与const">5.指针与const</span><a href="2019/05/13/指针_C++#undefined"></a></h4><p>将const关键字用于指针，有两种方式：</p><ol><li>将指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值；</li><li>将指针本身声明为常量，这样可以防止改变指向指针指向的位置。<br>首先，声明一个指向常量的指针pt：<figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></div></figure></li></ol><p>该声明支持，pt指向一个const int(这里为21)，因此不能使用pt来修改这个值，换句话说，*pt的值为const，不能被修改。但pt的声明并不意味着它指向的值实际上就是一个常量，而只是<strong>意味着对pt而言，这个值是常量</strong>。 例如，pt指向age，而age不是const。可以通过age变量修改age的值，但不能使用pt指针来修改它。</p><ul><li>将常规变量的地址赋给常规指针</li><li>将常规变量的地址赋给指向const的指针</li><li>将const变量的地址赋给指向const的指针</li><li>将const变量的地址赋给常规指针  (❌)</li></ul><p>尽可能使用const。 将指针参数声明为指向常量数据的指针有两条理由：</p><ol><li>可以避免由于无意间修改数据导致的编程错误</li><li>如果使用const使得函数能够处理const和非const实参，否则将只能接受非const数据<br>如果条件允许，应将指针行参声明为指向const的指针。</li></ol><h4><span id="函数指针">函数指针</span><a href="2019/05/13/指针_C++#undefined"></a></h4><p>与数据项类似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。<br>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的特征标(参数列表)，也就是说，声明应像函数原型那样指出有关函数的信息。例如原型如下：<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pam</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// prototype</span></span><br><span class="line"><span class="comment">// 指针类型如下</span></span><br><span class="line"><span class="keyword">double</span> (*pf)(<span class="keyword">int</span>);  <span class="comment">// *pf = pam</span></span><br></pre></td></tr></table></div></figure></p><p>由于pam是函数，因此(*pf)也是函数，pf就是<strong>函数指针</strong>。<br>通常，要声明指向特定类型的函数的指针时，可以首先编写这种函数的原型，然后用(*pf)替换函数名。这样pf就是这类函数的指针。<br>由于括号的优先级比*运算符高，因此在声明中使用括号将*pf括起。 *pf(int)意味着pf()是一个返回指针的函数，而(*pf)(int)意味着pf是一个指向函数的指针。</p><p>使用typedef简化函数指针<br><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字typedef可以创建类型别名：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> real;    <span class="comment">// 给double创建个别名real</span></span><br><span class="line">                        <span class="comment">// 将别名当作标识符进行声明，并在开头使用关键子typedef</span></span><br><span class="line"><span class="comment">// 因此，可将p_func声明为函数指针类型的别名：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">double</span>* (*p_func)(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>);  <span class="comment">// p_func(函数指针) 一个类型别名 </span></span><br><span class="line">p_func p1 = f1;</span><br><span class="line"></span><br><span class="line">p_func pa[<span class="number">3</span>] = &#123;f1, f2, f3&#125;;</span><br></pre></td></tr></table></div></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>学习设计模式总结<br><img src="/设计模式学习.jpg" alt="设计模式"></p><p>更详细的见<a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Patterns </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件可测试性</title>
      <link href="/2019/05/11/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E6%B5%8B%E6%80%A7/"/>
      <url>/2019/05/11/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E6%B5%8B%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>分析软件的可测试性，旨在加快测试进度、提高测试效率等。</p><p>软件的可测试性是指被测对象具有某些特征，如：<strong>可控制、可分解、稳定、易理解、可观察</strong>等。</p><p>可测性设计时需要保证的是：</p><ol><li>不对软件本身的功能产生影响；</li><li>不产生附加的测试。</li></ol><p><img src="/可测试性.jpg" alt="可测试性" class="article-img"></p><a id="more"></a><p>可测试性的具体体现：</p><ol><li>功能测试  相关点：功能、流程、输入输出等</li><li>性能测试  相关点：查询、保存、统计、刷新、显示、传输、响应、下载等</li><li>压力测试  相关点：大数据量的导入导出/计算/恢复/查询/接收时间、测试脚本/工具等</li><li>容错测试  相关点：断网、断电、死机等</li><li>并发测试  相关点：登录、提交、数据库操作等</li></ol>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试理论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>查找算法之二分查找</title>
      <link href="/2019/05/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/05/08/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<div class="article-bounded"><div class="article-table"><table><thead><tr><th>查找算法</th><th>平均时间复杂度</th><th>空间复杂度</th><th>查找条件</th></tr></thead><tbody><tr><td>顺序查找</td><td>O(n)</td><td>O(1)</td><td>无序或有序</td></tr><tr><td>二分查找(折半查找)</td><td>O(log~2~n)</td><td>O(1)</td><td>有序</td></tr><tr><td>插值查找</td><td>O(log~2~(log~2~n))</td><td>O(1)</td><td>有序</td></tr><tr><td>斐波那契查找</td><td>O(log~2~n)</td><td>O(1)</td><td>有序</td></tr><tr><td>哈希查找</td><td>O(1)</td><td>O(n)</td><td>无序或有序</td></tr></tbody></table></div></div><a id="more"></a><h1><span id="二分查找">二分查找</span><a href="2019/05/08/查找算法之二分查找#undefined"></a></h1><h3><span id="原理">原理</span><a href="2019/05/08/查找算法之二分查找#undefined"></a></h3><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。 </p><h3><span id="二分查找应用场景的局限性">二分查找应用场景的局限性</span><a href="2019/05/08/查找算法之二分查找#undefined"></a></h3><p>二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。但应用场景有很大局限性。</p><ol><li><p>二分查找依赖的是顺序表结构(eg: 数组)</p></li><li><p>二分查找针对的有序数据</p></li><li><p>数据量太小或太大均不适合使用二分查找 ( 数据量小的话，使用顺序查找；数据量大的话，由于依赖的是数组该数据结构，需要连续的大内存空间。而内存中会出现无这么大的内存块，导致申请空间失败)</p></li></ol><p><strong>[注意点]</strong>  容易出错的细节有：终止条件、区间上下界更新方法、返回值选择</p><h3><span id="简单实现">简单实现</span><a href="2019/05/08/查找算法之二分查找#undefined"></a></h3><p>递归与非递归简单实现如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">    非递归实现</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high):</span><br><span class="line">            <span class="comment"># mid = (low + high) // 2</span></span><br><span class="line">            <span class="comment"># mid = low + (high - low) // 2  # 比上述的优点是: 防止数组过大，(low+high)越界</span></span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span>  <span class="comment"># 比上述的优点是: 位运算比除法运算要快得多</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        递归实现</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.bsearchInternally(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>, target)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearchInternally</span><span class="params">(self, nums: List[int], low: int, high: int, target: int )</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> low &gt; high:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> self.bsearchInternally(nums, mid+<span class="number">1</span>, high, target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.bsearchInternally(nums, low, mid<span class="number">-1</span>, target)</span><br></pre></td></tr></table></div></figure><h3><span id="变形问题">变形问题</span><a href="2019/05/08/查找算法之二分查找#undefined"></a></h3><p>常见的二分查找变形问题</p><ul><li>查找第一个值等于给定值的元素</li><li>查找最后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_0</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 4</span></span><br><span class="line"><span class="string">            Output: 2</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更改相等时 逻辑处理</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> nums[mid - <span class="number">1</span>] != target</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_1</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 4</span></span><br><span class="line"><span class="string">            Output: 4</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 更改相等时 逻辑处理</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> nums[mid + <span class="number">1</span>] != target</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_2</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 3</span></span><br><span class="line"><span class="string">            Output: 2</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> (nums[mid - <span class="number">1</span>] &lt; target):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bsearch_3</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="string">        Input:  nums = [1, 3, 4, 4, 4, 5, 7]</span></span><br><span class="line"><span class="string">            target = 5</span></span><br><span class="line"><span class="string">            Output: 4</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">            mid = low + (high - low) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == mid) <span class="keyword">or</span> (nums[mid + <span class="number">1</span>] &gt; target):</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复杂度分析</title>
      <link href="/2019/05/01/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/01/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>如何分析、统计算法的执行效率(执行时间)和资源消耗(占用空间)？<br></p><p>数据结构和算法 解决的问题是”如何让计算机更快时间、更省空间”， 所以需要从执行时间、占用空间两个维度评估算法性能。复杂度分析 是时间复杂度和空间复杂度的统称，描述的是算法执行时间(占用空间)与数据规模的增长关系。和 性能测试 相比。复杂度分析不依赖执行环境、成本低、效率高、指导性强<br>        <strong>[复杂度分析]</strong> 一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法<br>        <strong>[性能的基准测试]</strong> 事后统计法：跑代码，通过统计、监控，得到算法执行的时间和占用的内存大小。得到的实验结果，受环境、数据规模大小因素影响较大<br><a id="more"></a></p><h3><span id="1大o表示法">1.大O表示法</span><a href="2019/05/01/复杂度分析#undefined"></a></h3><p>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n)) 表示。（其中T(n) 表示算法执行总时间，f(n) 表示每行代码执行总次数，而n往往表示的是数据规模）</p><p>分析法则：只关注循环执行次数最多的一段代码，若嵌套则相乘，若不同且规模不一则相加。</p><p>常用的复杂度级别：</p><ol><li>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包含有常数阶[O(1)]、对数阶[O(logn)]、线性阶[O(n)]、线性对数阶[O(nlogn)]、平方阶[O(n^2^)]、立方阶[O(n^3^)]、……</li><li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，性能极差。包含有指数阶[O(2^n^)]、阶乘阶[O(n!)]</li></ol><h3><span id="2时间复杂度知识点">2.时间复杂度知识点</span><a href="2019/05/01/复杂度分析#undefined"></a></h3><p>最好情况时间复杂度(best case time complexity)，在最理想的情况下，执行代码的时间复杂度。</p><p>最坏情况时间复杂度(worst case time complexity)，在最糟糕的情况下，执行代码的时间复杂度。</p><p>平均情况时间复杂度(average case time complexity)，即概率论中的加权平均值，也称期望值。所以平局时间复杂度= 加权平均时间复杂度= 期望平均时间复杂度</p><p>均摊时间复杂度(amortised case time complexity)，摊还分析法。<br>例子：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时许关系。这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平潭到其它那些时间复杂度较低的操作上。<br>一般，在能够应用均摊时间复杂度分析的场合，摊还时间复杂度就等于最好情况时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2018/12/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/12/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1><span id="排序">排序</span><a href="2018/12/22/排序算法#undefined"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">排序算法</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">最差时间复杂度</th><th style="text-align:left">空间复杂度</th><th style="text-align:left">数据对象稳定性</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">稳定</td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">数组不稳定、链表稳定</td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(log~2~n)</td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">希尔排序</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n^2^)</td><td style="text-align:left">O(1)</td><td style="text-align:left">不稳定</td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n*log~2~n)</td><td style="text-align:left">O(n)</td><td style="text-align:left">稳定</td></tr></tbody></table></div></div><a id="more"></a><h3><span id="冒泡排序">冒泡排序</span><a href="2018/12/22/排序算法#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序:（bubble sort）是一种简单的排序算法。</span></span><br><span class="line"><span class="string">    它重复地遍历要排列的序列，一词比较2个元素，如果它们的顺序错误就交换。遍历数列的</span></span><br><span class="line"><span class="string">工作是重复地进行直到没有再需要交换。即排序完成。步骤如下:</span></span><br><span class="line"><span class="string">    1. 比较相邻的元素，如果第二个比第一个大（升序），就交换；</span></span><br><span class="line"><span class="string">    2. 对每一对相邻元素作同样的工作，从开始的一对到最后的一对，找出最大的元素；</span></span><br><span class="line"><span class="string">    3. 针对所有的元素，重复以上步骤，除了最后一个；</span></span><br><span class="line"><span class="string">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n)  [表示遍历一次发现没有任何可以交换的元素，排序结束]</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">    <span class="comment">#外层确定次数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span> -j):</span><br><span class="line">        <span class="comment">#for i in range(0, n-1):</span></span><br><span class="line">        <span class="comment">#内存确定一个数（最大或最小）</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == count:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    bubble_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></div></figure><h3><span id="插入排序">插入排序</span><a href="2018/12/22/排序算法#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序（insertion sort）是一种简单直观的排序算法。工作原理：</span></span><br><span class="line"><span class="string">    通过构建有序序列，对于未排序数据，在已排序序列中向前扫描，找到相应位置并插入。</span></span><br><span class="line"><span class="string">    插入排序实现上，在从后向前扫描中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n) (升序，序列已处于升序状态)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># alist = [93,      54, 77, 31, 44, 55, 226]</span></span><br><span class="line"><span class="comment"># alist = [54, 93,      77, 31, 44, 55, 226]</span></span><br><span class="line"><span class="comment"># alist = [54, 77, 93,      31, 44, 55, 226]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 从右边的无序序列中取出多少个元素执行这样的过程</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># i = [1, 2, 3, ...,n-1]</span></span><br><span class="line">        <span class="comment"># i 代表内层循环起始值</span></span><br><span class="line">        i = j</span><br><span class="line">        <span class="comment"># 执行从右边的无序序列中取出第一个元素，即 i 位置的元素，然后插入到前面的正确位置中</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[i] &lt; alist[i<span class="number">-1</span>]:</span><br><span class="line">                alist[i<span class="number">-1</span>], alist[i] = alist[i], alist[i<span class="number">-1</span>]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># i=j j-1 j-2 ... 1   # range(j, 0, -1)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def insert_sort(alist):</span></span><br><span class="line"><span class="comment">#     for i in range(1, len(alist)):</span></span><br><span class="line"><span class="comment">#         for j in range(i, 0, -1):</span></span><br><span class="line"><span class="comment">#             if alist[i] &lt; alist[i-1]:</span></span><br><span class="line"><span class="comment">#                 alist[i], alist[i-1] = alist[i-1], alist[i]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    select_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></div></figure><h3><span id="选择排序">选择排序</span><a href="2018/12/22/排序算法#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序 (selection sort)是一种简单直观的排序算法。工作原理如下：</span></span><br><span class="line"><span class="string">    1. 在未排序序列中找到最小（大）元素存放到序列的起始位置；</span></span><br><span class="line"><span class="string">    2. 从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</span></span><br><span class="line"><span class="string">    3. 依次类推，直到排序完成。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># alist = [17, 20,     93, 54, 43, 67, 224, 23]</span></span><br><span class="line"><span class="comment">#          0   1       2   3   4   5   6    7</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># j = [0, 1, 2, 3..., n-2 ]</span></span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    select_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></div></figure><h3><span id="快速排序">快速排序</span><a href="2018/12/22/排序算法#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序（Quicksort）是一种比较排序，这意味着它可以对任何类型的项目进行</span></span><br><span class="line"><span class="string">排序.稳定的排序，这意味着相同的排序项目的相对顺序不会被保留，快速排序可以在数组</span></span><br><span class="line"><span class="string">上就地操作，需要少量额外的内存来执行排序。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [54,26,93,17,77,31,44,55,20]</span></span><br><span class="line"><span class="comment">#               |  |                    |</span></span><br><span class="line"><span class="comment">#      pivotvalue leftmark -&gt;       &lt;- rightmark</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    temp = data_list[leftmark]</span></span><br><span class="line"><span class="comment">#    data_list[leftmark] = data_list[rightmark]</span></span><br><span class="line"><span class="comment">#    data_list[rightmark] = temp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(data_list)</span>:</span></span><br><span class="line">    quickSortHlp(data_list,<span class="number">0</span>,len(data_list)<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSortHlp</span><span class="params">(data_list,first,last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        splitpoint = partition(data_list,first,last)</span><br><span class="line">        quickSortHlp(data_list,first,splitpoint<span class="number">-1</span>)</span><br><span class="line">        quickSortHlp(data_list,splitpoint+<span class="number">1</span>,last)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(data_list,first,last)</span>:</span></span><br><span class="line">    pivotvalue = data_list[first]</span><br><span class="line">    leftmark = first+<span class="number">1</span></span><br><span class="line">    rightmark = last</span><br><span class="line">    done = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">       <span class="keyword">while</span> leftmark &lt;= rightmark <span class="keyword">and</span> data_list[leftmark] &lt;= pivotvalue:</span><br><span class="line">           leftmark = leftmark + <span class="number">1</span></span><br><span class="line">       <span class="keyword">while</span> data_list[rightmark] &gt;= pivotvalue <span class="keyword">and</span> rightmark &gt;= leftmark:</span><br><span class="line">           rightmark = rightmark <span class="number">-1</span></span><br><span class="line">       <span class="keyword">if</span> rightmark &lt; leftmark:</span><br><span class="line">           done = <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           temp = data_list[leftmark]</span><br><span class="line">           data_list[leftmark] = data_list[rightmark]</span><br><span class="line">           data_list[rightmark] = temp</span><br><span class="line">    <span class="comment"># print(data_list,data_list[rightmark],rightmark)</span></span><br><span class="line">    temp = data_list[first]</span><br><span class="line">    data_list[first] = data_list[rightmark]</span><br><span class="line">    data_list[rightmark] = temp</span><br><span class="line">    <span class="keyword">return</span> rightmark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    quickSort(data_list)</span><br><span class="line">    print(data_list)</span><br></pre></td></tr></table></div></figure><h3><span id="希尔排序">希尔排序</span><a href="2018/12/22/排序算法#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序（shell sort）是插入排序的一种，也称缩小增量排序。是直接插入排序算法</span></span><br><span class="line"><span class="string">的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序</span></span><br><span class="line"><span class="string">算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被</span></span><br><span class="line"><span class="string">分成一组，算法终止。</span></span><br><span class="line"><span class="string">    基本思想：</span></span><br><span class="line"><span class="string">    将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长，</span></span><br><span class="line"><span class="string">列数更少）来进行。最后整个表就只有1列了。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： 根据步长序列的不同而不同</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># i = gap</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 插入算法，与普通的插入算法区别就是gap步长</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># i = [gap, gap+1, ..., n-1]</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i-gap]:</span><br><span class="line">                    alist[i], alist[i-gap] = alist[i-gap], alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    shell_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></div></figure><h3><span id="归并排序">归并排序</span><a href="2018/12/22/排序算法#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   归并排序（）采用分治法的一个典型应用。</span></span><br><span class="line"><span class="string">   归并排序的思想就是先递归分解数组，再合并数组。</span></span><br><span class="line"><span class="string">   将数组分解最小之后，然后合并2个有序数组，基本思路就是比较两个数组的最前面的数，</span></span><br><span class="line"><span class="string">谁小就先取谁，取了之后相应的指针往后移一位。然后再比较，直至一个数组为空，最后把另</span></span><br><span class="line"><span class="string">一个数组的剩余部分复制过来即可。</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  #最优时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">  #最坏时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">  #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># left 采用归并排序后有序的新的列表</span></span><br><span class="line">    left_list = merge_sort(alist[:mid])</span><br><span class="line">    <span class="comment"># right 采用归并排序后有序的新的列表</span></span><br><span class="line">    right_list = merge_sort(alist[mid:])</span><br><span class="line">    <span class="comment"># 将两个有序子列表合并为一个新列表</span></span><br><span class="line">    <span class="comment"># merge(left, right)</span></span><br><span class="line">    left_pointer, right_pointer = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left_pointer &lt; len(left_list) <span class="keyword">and</span> right_pointer &lt; len(right_list):</span><br><span class="line">        <span class="keyword">if</span> left_list[left_pointer] &lt;= right_list[right_pointer]:</span><br><span class="line">            result.append(left_list[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_list[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line">    result += left_list[left_pointer:]</span><br><span class="line">    result += right_list[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    sorted = merge_sort(data_list)</span><br><span class="line">    print(sorted)</span><br></pre></td></tr></table></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>To You</title>
      <link href="/2018/12/09/zxl01/"/>
      <url>/2018/12/09/zxl01/</url>
      
        <content type="html"><![CDATA[<p>20181209，两年零一天。<br>我喜欢你！</p>]]></content>
      
      
      <categories>
          
          <category> myself </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zlinna </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 基础学习</title>
      <link href="/2018/12/04/python_basic/"/>
      <url>/2018/12/04/python_basic/</url>
      
        <content type="html"><![CDATA[<h4><span id="一-类型与运算">一、类型与运算</span><a href="2018/12/04/python_basic#undefined"></a></h4><h5><span id="1寻求帮助">1.寻求帮助</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir(obj)          <span class="comment"># 简单的列出对象obj所包含的方法名称，返回一个字符串列表</span></span><br><span class="line">help(obj.func)    <span class="comment"># 查询obj.func的具体介绍和用法</span></span><br></pre></td></tr></table></div></figure><h5><span id="2测试类型的方法-推荐3">2.测试类型的方法 （推荐3）</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> type(L) == type([]):</span><br><span class="line">    print(<span class="string">"L is list"</span>）</span><br><span class="line"><span class="keyword">if</span> type(L) == list:</span><br><span class="line">    print(<span class="string">"L is list"</span>）</span><br><span class="line"><span class="keyword">if</span> isinstance(L, list):</span><br><span class="line">    print(<span class="string">"L is list"</span>）</span><br></pre></td></tr></table></div></figure><h5><span id="3python数据类型哈希不可哈希">3.Python数据类型：哈希/不可哈希</span><a href="2018/12/04/python_basic#undefined"></a></h5><p>哈希类型。不可变类型，可利用hash函数查看其hash值，也可以作为字典的key。具体有：</p><blockquote><p>数字类型：int, float, decimal.Decimal, fraction.Fraction, complex</p><p>字符串类型：str, bytes</p><p>元祖：tuple</p><p>冻结集合：frozenset</p><p>布尔类型：True， False</p><p>None</p></blockquote><p>不可哈希类型。可变类型，不可以作为字典的key。有：list, dict, set</p><a id="more"></a><h5><span id="4数字常量">4.数字常量</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span>, <span class="number">-1234</span>, <span class="number">0</span>, <span class="number">999999999</span>             <span class="comment"># 整数</span></span><br><span class="line"><span class="number">1.23</span>, <span class="number">1.</span>, <span class="number">3.14e-10</span>, <span class="number">4E210</span>, <span class="number">4.0e+210</span>   <span class="comment"># 浮点数</span></span><br><span class="line"><span class="number">0o177</span>, <span class="number">0x9ff</span>, <span class="number">0X9FF</span>, <span class="number">0b101010</span>         <span class="comment"># 八进制、十六进制、二进制数字</span></span><br><span class="line"><span class="number">3</span>+<span class="number">4j</span>, <span class="number">3.0</span>+<span class="number">4.0j</span>, <span class="number">3J</span>           <span class="comment"># 复数常量，也可以用complex(real, image)来创建</span></span><br><span class="line">hex(I), oct(I), bin(I)       <span class="comment"># 将十进制数转化为十六进制、八进制、二进制表示的“字符串”</span></span><br><span class="line">int(string, base)                     <span class="comment"># 将字符串转化为整数，base为进制数</span></span><br><span class="line"><span class="comment"># 2.x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数</span></span><br><span class="line">float(<span class="string">'inf'</span>), float(<span class="string">'-inf'</span>), float(<span class="string">'nan'</span>)    <span class="comment"># 无穷大, 无穷小, 非数</span></span><br></pre></td></tr></table></div></figure><h5><span id="5数字的表达式操作符">5.数字的表达式操作符</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> x                           <span class="comment"># 生成器函数发送协议</span></span><br><span class="line"><span class="keyword">lambda</span> args: expression           <span class="comment"># 生成匿名函数</span></span><br><span class="line">x <span class="keyword">if</span> y <span class="keyword">else</span> z                     <span class="comment"># 三元选择表达式</span></span><br><span class="line">x <span class="keyword">and</span> y, x <span class="keyword">or</span> y, <span class="keyword">not</span> x            <span class="comment"># 逻辑与、逻辑或、逻辑非</span></span><br><span class="line">x <span class="keyword">in</span> y, x <span class="keyword">not</span> <span class="keyword">in</span> y                <span class="comment"># 成员对象测试</span></span><br><span class="line">x <span class="keyword">is</span> y, x <span class="keyword">is</span> <span class="keyword">not</span> y                <span class="comment"># 对象实体测试</span></span><br><span class="line">x&lt;y, x&lt;=y, x&gt;y, x&gt;=y, x==y, x!=y    <span class="comment"># 大小比较，集合子集或超集值相等性操作符</span></span><br><span class="line"><span class="number">1</span> &lt; a &lt; <span class="number">3</span>                         <span class="comment"># Python中允许连续比较</span></span><br><span class="line">x|y, x&amp;y, x^y                     <span class="comment"># 位或、位与、位异或</span></span><br><span class="line">x&lt;&lt;y, x&gt;&gt;y                        <span class="comment"># 位操作：x左移、右移y位</span></span><br><span class="line">+, -, *, /, //, %, **             <span class="comment"># 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算</span></span><br><span class="line">-x, +x, ~x                        <span class="comment"># 一元减法、识别、按位求补（取反）</span></span><br><span class="line">x[i], x[i:j:k]                    <span class="comment"># 索引、分片、调用</span></span><br><span class="line">int(<span class="number">3.14</span>), float(<span class="number">3</span>)               <span class="comment"># 强制类型转换</span></span><br></pre></td></tr></table></div></figure><h5><span id="6整数可计算所占位数">6.整数可计算所占位数</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a.bit_length()  <span class="comment"># 1位</span></span><br><span class="line">b = <span class="number">1024</span></span><br><span class="line">b.bit_length()  <span class="comment"># 11位</span></span><br></pre></td></tr></table></div></figure><h5><span id="7repr和str的区别">7.repr和str的区别</span><a href="2018/12/04/python_basic#undefined"></a></h5><ul><li>repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。</li><li>str格式：打印语句，转化成一种对用户更加友好的格式。</li></ul><h5><span id="8数字相关模块">8.数字相关模块</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># math模块</span></span><br><span class="line"><span class="comment"># Decimal模块：小数模块</span></span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">Decimal(<span class="string">"0.01"</span>) + Decimal(<span class="string">"0.02"</span>)        <span class="comment"># 返回Decimal("0.03")</span></span><br><span class="line">decimal.getcontext().prec = <span class="number">4</span>            <span class="comment"># 设置全局精度为4 即小数点后边4位</span></span><br><span class="line"><span class="comment"># Fraction模块：分数模块</span></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line">x = Fraction(<span class="number">4</span>, <span class="number">6</span>)                       <span class="comment"># 分数类型 4/6</span></span><br><span class="line">x = Fraction(<span class="string">"0.25"</span>)                     <span class="comment"># 分数类型 1/4 接收字符串类型的参数</span></span><br></pre></td></tr></table></div></figure><h5><span id="9集合set">9.集合set</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">set是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。</span></span><br><span class="line"><span class="string">set支持union(联合),intersection(交),difference(差)和symmetric_difference(对称差集)数学运算。</span></span><br><span class="line"><span class="string">set支持x in set, len(set), for x in set。</span></span><br><span class="line"><span class="string">set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = set([<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>])                          <span class="comment"># 创建一个数值集合，返回&#123;3, 5, 9, 10&#125;</span></span><br><span class="line">t = set(<span class="string">"Hello"</span>)                             <span class="comment"># 创建一个唯一字符的集合返回&#123;&#125;</span></span><br><span class="line">a = t | s;    t.union(s)                     <span class="comment"># t 和 s的并集</span></span><br><span class="line">b = t &amp; s;    t.intersection(s)              <span class="comment"># t 和 s的交集</span></span><br><span class="line">c = t – s;    t.difference(s)                <span class="comment"># 求差集（项在t中, 但不在s中）</span></span><br><span class="line">d = t ^ s;    t.symmetric_difference(s)      <span class="comment"># 对称差集（项在t或s中, 但不会同时出现在二者中）</span></span><br><span class="line">t.add(<span class="string">'x'</span>);   t.remove(<span class="string">'H'</span>)                  <span class="comment"># 增加/删除一个item</span></span><br><span class="line">s.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])                         <span class="comment"># 利用[......]更新s集合</span></span><br><span class="line">x <span class="keyword">in</span> s,  x <span class="keyword">not</span> <span class="keyword">in</span> s                          <span class="comment"># 集合中是否存在某个值</span></span><br><span class="line">s.issubset(t);      s &lt;= t                   <span class="comment"># 测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line">s.issuperset(t);    s &gt;= t                   <span class="comment"># 测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line">s.copy();</span><br><span class="line">s.discard(x);                                <span class="comment"># 删除s中x</span></span><br><span class="line">s.clear()                                    <span class="comment"># 清空s</span></span><br><span class="line">&#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;                 <span class="comment"># 集合解析，结果：&#123;16, 1, 4, 9&#125;</span></span><br><span class="line">&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span>&#125;                          <span class="comment"># 集合解析，结果：&#123;'a', 'p', 's', 'm'&#125;</span></span><br></pre></td></tr></table></div></figure><h5><span id="10冻结集合frozenset">10.冻结集合frozenset</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list等(tuple是可以作为字典key的)</span></span><br><span class="line"><span class="string">frozenset是不可变对象，即存在hash值，可作为字典的键值</span></span><br><span class="line"><span class="string">frozenset对象没有add、remove等方法，但有union/intersection/difference等方法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">a = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">b = set()</span><br><span class="line">b.add(a)                     <span class="comment"># error: set是不可哈希类型</span></span><br><span class="line">b.add(frozenset(a))          <span class="comment"># ok，将set变为frozenset，可哈希</span></span><br></pre></td></tr></table></div></figure><h5><span id="11布尔类型bool">11.布尔类型bool</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="keyword">True</span>)                   <span class="comment"># 返回&lt;class 'bool'&gt;</span></span><br><span class="line">isinstance(<span class="keyword">False</span>, int)       <span class="comment"># bool类型属于整型，所以返回True</span></span><br><span class="line"><span class="keyword">True</span> == <span class="number">1</span>; <span class="keyword">True</span> <span class="keyword">is</span> <span class="number">1</span>         <span class="comment"># 输出(True, False)</span></span><br></pre></td></tr></table></div></figure><h5><span id="12动态类型简介">12.动态类型简介</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">变量名通过引用，指向对象。</span></span><br><span class="line"><span class="string">Python中的“类型”属于对象，而不是变量，每个对象都包含有头部信息，比如"类型标示符" "引用计数器"等</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！</span></span><br><span class="line"><span class="comment">#共享引用和相等测试：</span></span><br><span class="line">    L = [<span class="number">1</span>], M = [<span class="number">1</span>], L <span class="keyword">is</span> M            <span class="comment"># 返回False</span></span><br><span class="line">    L = M = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], L <span class="keyword">is</span> M           <span class="comment"># 返回True，共享引用</span></span><br><span class="line"><span class="comment">#增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+=会在原处修改</span></span><br><span class="line">    L = M = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    L = L + [<span class="number">3</span>, <span class="number">4</span>]                      <span class="comment"># L = [1, 2, 3, 4], M = [1, 2]</span></span><br><span class="line">    L += [<span class="number">3</span>, <span class="number">4</span>]                         <span class="comment"># L = [1, 2, 3, 4], M = [1, 2, 3, 4]</span></span><br></pre></td></tr></table></div></figure><h5><span id="13常见字符串常量和表达式">13.常见字符串常量和表达式</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">''</span>                                  <span class="comment"># 空字符串</span></span><br><span class="line">S = <span class="string">"spam’s"</span>                            <span class="comment"># 双引号和单引号相同</span></span><br><span class="line">S = <span class="string">"s\np\ta\x00m"</span>                      <span class="comment"># 转义字符</span></span><br><span class="line">S = <span class="string">"""spam"""</span>                          <span class="comment"># 三重引号字符串，一般用于函数说明</span></span><br><span class="line">S = <span class="string">r'\temp'</span>                            <span class="comment"># Raw字符串，不会进行转义，抑制转义</span></span><br><span class="line">S = <span class="string">b'Spam'</span>                             <span class="comment"># Python3中的字节字符串</span></span><br><span class="line">S = <span class="string">u'spam'</span>                             <span class="comment"># Python2.6中的Unicode字符串</span></span><br><span class="line">s1+s2, s1*<span class="number">3</span>, s[i], s[i:j], len(s)       <span class="comment"># 字符串操作</span></span><br><span class="line"><span class="string">'a %s parrot'</span> % <span class="string">'kind'</span>                  <span class="comment"># 字符串格式化表达式</span></span><br><span class="line"><span class="string">'a &#123;1&#125; &#123;0&#125; parrot'</span>.format(<span class="string">'kind'</span>, <span class="string">'red'</span>)<span class="comment"># 字符串格式化方法</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> s: print(x)                    <span class="comment"># 字符串迭代，成员关系</span></span><br><span class="line">[x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]                        <span class="comment"># 字符串列表解析</span></span><br><span class="line"><span class="string">','</span>.join([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])               <span class="comment"># 字符串输出，结果：a,b,c</span></span><br></pre></td></tr></table></div></figure><h5><span id="14内置str处理函数">14.内置str处理函数</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"stringobject"</span></span><br><span class="line"><span class="comment"># 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写</span></span><br><span class="line">str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title()        </span><br><span class="line">str1.ljust(width)                       <span class="comment"># 获取固定长度，左对齐，右边不够用空格补齐</span></span><br><span class="line">str1.rjust(width)                       <span class="comment"># 获取固定长度，右对齐，左边不够用空格补齐</span></span><br><span class="line">str1.center(width)                      <span class="comment"># 获取固定长度，中间对齐，两边不够用空格补齐</span></span><br><span class="line">str1.zfill(width)                       <span class="comment"># 获取固定长度，右对齐，左边不足用0补齐</span></span><br><span class="line">str1.find(<span class="string">'t'</span>,start,end)                <span class="comment"># 查找字符串，可以指定起始及结束位置搜索</span></span><br><span class="line">str1.rfind(<span class="string">'t'</span>)                         <span class="comment"># 从右边开始查找字符串</span></span><br><span class="line">str1.count(<span class="string">'t'</span>)                         <span class="comment"># 查找字符串出现的次数</span></span><br><span class="line"><span class="comment"># 上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1</span></span><br><span class="line"><span class="comment"># ---  --- #</span></span><br><span class="line"><span class="comment"># 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new</span></span><br><span class="line">str1.replace(<span class="string">'old'</span>,<span class="string">'new'</span>)               </span><br><span class="line">str1.strip();                           <span class="comment"># 默认删除空白符</span></span><br><span class="line">str1.strip(<span class="string">'d'</span>);                        <span class="comment"># 删除str1字符串中开头、结尾处，位于 d 删除序列的字符</span></span><br><span class="line">str1.lstrip();</span><br><span class="line">str1.lstrip(<span class="string">'d'</span>);                       <span class="comment"># 删除str1字符串中开头处，位于 d 删除序列的字符</span></span><br><span class="line">str1.rstrip();</span><br><span class="line">str1.rstrip(<span class="string">'d'</span>)                        <span class="comment"># 删除str1字符串中结尾处，位于 d 删除序列的字符</span></span><br><span class="line">str1.startswith(<span class="string">'start'</span>)                <span class="comment"># 是否以start开头</span></span><br><span class="line">str1.endswith(<span class="string">'end'</span>)                    <span class="comment"># 是否以end结尾</span></span><br><span class="line"><span class="comment"># 判断字符串是否全为字符、数字、小写、大写</span></span><br><span class="line">str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper()</span><br></pre></td></tr></table></div></figure><h5><span id="15字符串转换及另类拼接">15.字符串转换及另类拼接</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.转换</span></span><br><span class="line">int(<span class="string">'42'</span>), str(<span class="number">42</span>)                      <span class="comment"># 返回(42, '42')</span></span><br><span class="line">float(<span class="string">'4.13'</span>), str(<span class="number">4.13</span>)                <span class="comment"># 返回(4.13, '4.13')</span></span><br><span class="line">ord(<span class="string">'s'</span>), chr(<span class="number">115</span>)                      <span class="comment"># 返回(115, 's')</span></span><br><span class="line">int(<span class="string">'1001'</span>, <span class="number">2</span>)                          <span class="comment"># 将字符串作为二进制数字，转化为数字，返回9</span></span><br><span class="line"><span class="comment"># 将整数转化为二进制/八进制/十六进制字符串，返回('0b1101', '015', '0xd')</span></span><br><span class="line">bin(<span class="number">13</span>), oct(<span class="number">13</span>), hex(<span class="number">13</span>)</span><br><span class="line"><span class="comment"># 2.另类拼接</span></span><br><span class="line">name = <span class="string">"wang"</span> <span class="string">"wg"</span>                    <span class="comment"># 单行，name = "wangwg"</span></span><br><span class="line">name = <span class="string">"wang"</span> \</span><br><span class="line">        <span class="string">"wg"</span>                          <span class="comment"># 多行，name = "wangwg"</span></span><br></pre></td></tr></table></div></figure><h5><span id="16字符串格式化">16.字符串格式化</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 1.字符串格式化表达式 ###</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">基于C语言的'print'模型，并且在大多数的现有的语言中使用。</span></span><br><span class="line"><span class="string">通用结构：%[(name)][flag][width].[precision]typecode</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"this is %d %s bird"</span> % (<span class="number">1</span>, <span class="string">'dead'</span>)                   <span class="comment"># 一般的格式化表达式</span></span><br><span class="line"><span class="string">"%s---%s---%s"</span> % (<span class="number">42</span>, <span class="number">3.14</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])               <span class="comment"># 字符串输出：'42---3.14---[1, 2, 3]'</span></span><br><span class="line"><span class="comment"># 对齐方式及填充："1234...  1234...1234  ...001234"</span></span><br><span class="line"><span class="string">"%d...%6d...%-6d...%06d"</span> % (<span class="number">1234</span>, <span class="number">1234</span>, <span class="number">1234</span>, <span class="number">1234</span>)         </span><br><span class="line">x = <span class="number">1.23456789</span></span><br><span class="line"><span class="string">"%e | %f | %g"</span> % (x, x, x)                <span class="comment"># 对齐方式："1.234568e+00 | 1.234568 | 1.23457"</span></span><br><span class="line"><span class="string">"%6.2f*%-6.2f*%06.2f*%+6.2f"</span> % (x, x, x, x)     <span class="comment"># 对齐方式：'  1.23*1.23  *001.23* +1.23'</span></span><br><span class="line"><span class="string">"%(name1)d---%(name2)s"</span> % &#123;<span class="string">"name1"</span>:<span class="number">23</span>, <span class="string">"name2"</span>:<span class="string">"value2"</span>&#125;           <span class="comment"># 基于字典的格式化表达式</span></span><br><span class="line"><span class="string">"%(name)s is %(age)d"</span> % vars()    <span class="comment"># vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.字符串格式化调用方法 ###</span></span><br><span class="line"><span class="comment"># 普通调用</span></span><br><span class="line"><span class="string">"&#123;0&#125;, &#123;1&#125; and &#123;2&#125;"</span>.format(<span class="string">'spam'</span>, <span class="string">'ham'</span>, <span class="string">'eggs'</span>)            <span class="comment"># 基于位置的调用</span></span><br><span class="line"><span class="string">"&#123;motto&#125; and &#123;pork&#125;"</span>.format(motto = <span class="string">'spam'</span>, pork = <span class="string">'ham'</span>)   <span class="comment"># 基于Key的调用</span></span><br><span class="line"><span class="string">"&#123;motto&#125; and &#123;0&#125;"</span>.format(<span class="string">'ham'</span>, motto = <span class="string">'spam'</span>)             <span class="comment"># 混合调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加键 属性 偏移量 (import sys)</span></span><br><span class="line"><span class="comment"># 基于位置的键和属性</span></span><br><span class="line"><span class="string">"my &#123;1[spam]&#125; runs &#123;0.platform&#125;"</span>.format(sys, &#123;<span class="string">'spam'</span>:<span class="string">'laptop'</span>&#125;)</span><br><span class="line"><span class="comment"># 基于Key的键和属性</span></span><br><span class="line"><span class="string">"&#123;config[spam]&#125; &#123;sys.platform&#125;"</span>.format(sys = sys, config = &#123;<span class="string">'spam'</span>:<span class="string">'laptop'</span>&#125;)</span><br><span class="line"><span class="comment"># 基于位置的偏移量</span></span><br><span class="line"><span class="string">"first = &#123;0[0]&#125;, second = &#123;0[1]&#125;"</span>.format([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体格式化</span></span><br><span class="line"><span class="comment"># 输出'3.141590e+00, 3.142e+00, 3.14159'</span></span><br><span class="line"><span class="string">"&#123;0:e&#125;, &#123;1:.3e&#125;, &#123;2:g&#125;"</span>.format(<span class="number">3.14159</span>, <span class="number">3.14159</span>, <span class="number">3.14159</span>)</span><br><span class="line"><span class="string">"&#123;fieldname:format_spec&#125;"</span>.format(......)</span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    fieldname是指定参数的一个数字或关键字, 后边可跟可选的".name"或"[index]"成分引用</span></span><br><span class="line"><span class="string">    format_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type]</span></span><br><span class="line"><span class="string">    fill        ::=  &lt;any character&gt;              #填充字符</span></span><br><span class="line"><span class="string">    align       ::=  "&lt;" | "&gt;" | "=" | "^"        #对齐方式</span></span><br><span class="line"><span class="string">    sign        ::=  "+" | "-" | " "              #符号说明</span></span><br><span class="line"><span class="string">    width       ::=  integer                      #字符串宽度</span></span><br><span class="line"><span class="string">    precision   ::=  integer                      #浮点数精度</span></span><br><span class="line"><span class="string">    type        ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 例子:</span></span><br><span class="line">    <span class="string">'=&#123;0:10&#125; = &#123;1:10&#125;'</span>.format(<span class="string">'spam'</span>, <span class="number">123.456</span>)    <span class="comment"># 输出'=spam       =    123.456'</span></span><br><span class="line">    <span class="string">'=&#123;0:&gt;10&#125;='</span>.format(<span class="string">'test'</span>)                    <span class="comment"># 输出'=      test='</span></span><br><span class="line">    <span class="string">'=&#123;0:&lt;10&#125;='</span>.format(<span class="string">'test'</span>)                    <span class="comment"># 输出'=test      ='</span></span><br><span class="line">    <span class="string">'=&#123;0:^10&#125;='</span>.format(<span class="string">'test'</span>)                    <span class="comment"># 输出'=   test   ='</span></span><br><span class="line">    <span class="string">'&#123;0:X&#125;, &#123;1:o&#125;, &#123;2:b&#125;'</span>.format(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)   <span class="comment"># 输出'FF, 377, 11111111'</span></span><br><span class="line">    <span class="string">'My name is &#123;0:&#123;1&#125;&#125;.'</span>.format(<span class="string">'Fred'</span>, <span class="number">7</span>)       <span class="comment"># 输出'My name is Fred   .' 动态指定参数</span></span><br></pre></td></tr></table></div></figure><h5><span id="17索引和分片">17.索引和分片</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">0</span>], S[len(S)–<span class="number">1</span>], S[<span class="number">-1</span>]   <span class="comment"># 索引</span></span><br><span class="line"><span class="comment"># 分片，第三个参数指定步长，如S[1:10:2]是从1位到10位没隔2位获取一个字符。</span></span><br><span class="line">S[<span class="number">1</span>:<span class="number">3</span>], S[<span class="number">1</span>:], S[:<span class="number">-1</span>], S[<span class="number">1</span>:<span class="number">10</span>:<span class="number">2</span>]  <span class="comment"># list[begin:end:step]</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = []  <span class="comment"># 删除列表中1-4号元素后： a = [1, 5, 6, 7]</span></span><br><span class="line">b = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">del</span> b[::<span class="number">2</span>]   <span class="comment"># 去除偶数项(偶数索引的), b = [1, 3, 5, 7]</span></span><br></pre></td></tr></table></div></figure><h5><span id="18常用列表常量和操作">18.常用列表常量和操作</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">L = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">'string'</span>, &#123;&#125;]                        <span class="comment"># 嵌套列表</span></span><br><span class="line">L = list(<span class="string">'spam'</span>)                                  <span class="comment"># 列表初始化</span></span><br><span class="line">L = list(range(<span class="number">0</span>, <span class="number">4</span>))                             <span class="comment"># 列表初始化</span></span><br><span class="line">list(map(ord, <span class="string">'spam'</span>))                            <span class="comment"># 列表解析</span></span><br><span class="line">len(L)                                            <span class="comment"># 求列表长度</span></span><br><span class="line">L.count(value)                                    <span class="comment"># 求列表中某个值的个数</span></span><br><span class="line">L.append(obj)                          <span class="comment"># 向列表的尾部添加数据，比如append(2)，添加元素2</span></span><br><span class="line">L.insert(index, obj)                   <span class="comment"># 向列表的指定index位置添加数据，index及其之后的数据后移</span></span><br><span class="line"><span class="comment"># 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别</span></span><br><span class="line">L.extend(interable)                     </span><br><span class="line">L.index(value, [start, [stop]])        <span class="comment"># 返回列表中值value的第一个索引</span></span><br><span class="line">L.pop([index])                         <span class="comment"># 删除并返回index处的元素，默认为删除并返回最后一个元素</span></span><br><span class="line">L.remove(value)                        <span class="comment"># 删除列表中的value值，只删除第一次出现的value的值</span></span><br><span class="line">L.reverse()                                       <span class="comment"># 反转列表</span></span><br><span class="line">L.sort(cmp=<span class="keyword">None</span>, key=<span class="keyword">None</span>, reverse=<span class="keyword">False</span>)         <span class="comment"># 排序列表</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], b = a[<span class="number">10</span>:]              <span class="comment"># 注意，不会引发IndexError异常，只会返回一个空列表[]</span></span><br><span class="line">a = [], a += [<span class="number">1</span>]                       <span class="comment"># 这里实在原有列表的基础上进行操作，即列表的id没有改变</span></span><br><span class="line">a = [], a = a + [<span class="number">1</span>]                    <span class="comment"># 这里最后的a要构建一个新的列表，即a的id发生了变化</span></span><br></pre></td></tr></table></div></figure><h5><span id="19常用字典常量和操作">19.常用字典常量和操作</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D = &#123;&#125;</span><br><span class="line">D = &#123;<span class="string">'spam'</span>:<span class="number">2</span>, <span class="string">'tol'</span>:&#123;<span class="string">'ham'</span>:<span class="number">1</span>&#125;&#125;                   <span class="comment"># 嵌套字典</span></span><br><span class="line">D = dict.fromkeys([<span class="string">'s'</span>, <span class="string">'d'</span>], <span class="number">8</span>)                  <span class="comment"># &#123;'s': 8, 'd': 8&#125;</span></span><br><span class="line">D = dict(name = <span class="string">'tom'</span>, age = <span class="number">12</span>)                  <span class="comment"># &#123;'age': 12, 'name': 'tom'&#125;</span></span><br><span class="line">D = dict([(<span class="string">'name'</span>, <span class="string">'tom'</span>), (<span class="string">'age'</span>, <span class="number">12</span>)])          <span class="comment"># &#123;'age': 12, 'name': 'tom'&#125;</span></span><br><span class="line">D = dict(zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'tom'</span>, <span class="number">12</span>]))       <span class="comment"># &#123;'age': 12, 'name': 'tom'&#125;</span></span><br><span class="line">D.keys(); D.values(); D.items()                   <span class="comment"># 字典键、值以及键值对</span></span><br><span class="line">D.get(key, default)                               <span class="comment"># get函数</span></span><br><span class="line">D.update(D_other)   <span class="comment"># 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据</span></span><br><span class="line">D.pop(key, [D])   <span class="comment"># 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常</span></span><br><span class="line">D.popitem()                                       <span class="comment"># pop字典中随机的一项（一个键值对）</span></span><br><span class="line"><span class="comment"># 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。</span></span><br><span class="line">D.setdefault(k[, d])</span><br><span class="line"><span class="keyword">del</span> D                                             <span class="comment"># 删除字典</span></span><br><span class="line"><span class="keyword">del</span> D[<span class="string">'key'</span>]                                      <span class="comment"># 删除字典的某一项</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> D:   <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> D:                   <span class="comment"># 测试字典键是否存在</span></span><br><span class="line"><span class="comment"># 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象</span></span><br><span class="line"><span class="comment"># 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。</span></span><br><span class="line"><span class="comment"># 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象</span></span><br><span class="line">D[(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)] = <span class="number">2</span>                                    <span class="comment"># tuple作为字典的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典解析</span></span><br><span class="line">D = &#123;k:<span class="number">8</span> <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="string">'s'</span>, <span class="string">'d'</span>]&#125;                                <span class="comment"># &#123;'s': 8, 'd': 8&#125;</span></span><br><span class="line">D = &#123;k:v <span class="keyword">for</span> (k, v) <span class="keyword">in</span> zip([<span class="string">'name'</span>, <span class="string">'age'</span>], [<span class="string">'tom'</span>, <span class="number">12</span>])&#125;    <span class="comment"># &#123;'age': 12, 'name': tom&#125;</span></span><br></pre></td></tr></table></div></figure><h5><span id="20文件基本操作">20.文件基本操作</span><a href="2018/12/04/python_basic#undefined"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">output = open(<span class="string">r'C:\spam'</span>, <span class="string">'w'</span>)          <span class="comment"># 打开输出文件，用于写</span></span><br><span class="line">input = open(<span class="string">'data'</span>, <span class="string">'r'</span>)               <span class="comment"># 打开输入文件，用于读。打开的方式可以为'w', 'r', 'a', 'wb', 'rb', 'ab'等</span></span><br><span class="line">fp.read([size])                         <span class="comment"># size为读取的长度，以byte为单位</span></span><br><span class="line">fp.readline([size])                     <span class="comment"># 读一行，如果定义了size，有可能返回的只是一行的一部分</span></span><br><span class="line">fp.readlines([size])                    <span class="comment"># 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。</span></span><br><span class="line">fp.readable()                           <span class="comment"># 是否可读</span></span><br><span class="line">fp.write(str)                           <span class="comment"># 把str写到文件中，write()并不会在str后加上一个换行符</span></span><br><span class="line">fp.writelines(seq)                      <span class="comment"># 把seq的内容全部写到文件中(多行一次性写入)</span></span><br><span class="line">fp.writeable()                          <span class="comment"># 是否可写</span></span><br><span class="line">fp.close()                              <span class="comment"># 关闭文件。</span></span><br><span class="line">fp.flush()                              <span class="comment"># 把缓冲区的内容写入硬盘</span></span><br><span class="line">fp.fileno()                             <span class="comment"># 返回一个长整型的”文件标签“</span></span><br><span class="line">fp.isatty()                             <span class="comment"># 文件是否是一个终端设备文件（unix系统中的）</span></span><br><span class="line">fp.tell()                               <span class="comment"># 返回文件操作标记的当前位置，以文件的开头为原点</span></span><br><span class="line">fp.next()                               <span class="comment"># 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</span></span><br><span class="line">fp.seek(offset[,whence])                <span class="comment"># 将文件打开操作标记移到offset的位置。whence为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。</span></span><br><span class="line">fp.seekable()                           <span class="comment"># 是否可以seek</span></span><br><span class="line">fp.truncate([size])                     <span class="comment"># 把文件裁成规定的大小，默认裁到当前文件操作标记的位置。</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'data'</span>):</span><br><span class="line">    print(line)                         <span class="comment"># 使用for语句，比较适用于打开比较大的文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    print(file.readline())              <span class="comment"># 使用with语句，可以保证文件关闭</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    lines = file.readlines()            <span class="comment"># 一次读入文件所有行，并关闭文件</span></span><br><span class="line">open(<span class="string">'f.txt'</span>, encoding = <span class="string">'latin-1'</span>)     <span class="comment"># Python3.x Unicode文本文件</span></span><br><span class="line">open(<span class="string">'f.bin'</span>, <span class="string">'rb'</span>)                     <span class="comment"># Python3.x 二进制bytes文件</span></span><br><span class="line"><span class="comment"># 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等</span></span><br></pre></td></tr></table></div></figure><h5><span id="21其它">21.其它</span><a href="2018/12/04/python_basic#undefined"></a></h5><ul><li>Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真</li><li>通常意义下的类型分类： 1. 数字、序列、映射。 2. 可变类型和不可变类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/03/hello-world/"/>
      <url>/2018/12/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span><a href="2018/12/03/hello-world#undefined"></a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="2018/12/03/hello-world#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span><a href="2018/12/03/hello-world#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><a id="more"></a><h3><span id="generate-static-files">Generate static files</span><a href="2018/12/03/hello-world#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><!--more--><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="2018/12/03/hello-world#undefined"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
