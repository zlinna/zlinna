{"per_page":8,"total":3,"current":2,"data":[{"title":"测试角度学习 cache2go","date":"2019-08-20T13:44:35.633Z","date_formatted":{"ll":"Aug 20, 2019","L":"08/20/2019","MM-DD":"08-20"},"excerpt":"<h1 id=\"cache2go-介绍\">cache2go 介绍<a href=\"2019/08/20/测试角度学习cache2go#cache2go-介绍\"></a></h1><p>“Concurrency-safe golang caching library with expiration capabilities.”。作者如是介绍该项目，翻译后的意思为：存在心跳机制且并发安全的go语言缓存库。</p>\n<h3 id=\"tips\">tips<a href=\"2019/08/20/测试角度学习cache2go#tips\"></a></h3><p>测试行为，而非实施。 “The public API of a package declare this is what(行为) I do, not this is <del>how(实施)</del> I do it.”</p>\n<h3 id=\"测试角度学习-cache2go\">测试角度学习 cache2go<a href=\"2019/08/20/测试角度学习cache2go#测试角度学习-cache2go\"></a></h3><p>我们知道心跳机制、并发安全是 cache2go 的两大特点，那么肯定是测试的重点了。 【Cachetable 简称 table，cacheitem 简称 item】</p>\n<p>首先查看 cache_test.go ，可以获得以下信息：<br></p>","link":"2019/08/20/测试角度学习cache2go","tags":["Go","测试实践"],"categories":["test"]},{"title":"Go Testing;How,What,Why","date":"2019-07-28T02:43:54.507Z","date_formatted":{"ll":"Jul 28, 2019","L":"07/28/2019","MM-DD":"07-28"},"excerpt":"<h2 id=\"前言\">前言<a href=\"2019/07/28/Go_Testing#前言\"></a></h2><p>关于 Go 测试，我们应该知道测试方式（或者说测试手段）、测试对象及测试原因。</p>\n<h2 id=\"How-测试方式\">How 测试方式<a href=\"2019/07/28/Go_Testing#How-测试方式\"></a></h2><h3 id=\"测试实现\">测试实现<a href=\"2019/07/28/Go_Testing#测试实现\"></a></h3><p>举个例子。针对字符串分割函数（如下），实现单元测试。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> goTest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"strings\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Split slices s into all substrings separated by sep and</span></span><br><span class=\"line\"><span class=\"comment\">// returns a slice of the substrings between those separators.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Split</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result []<span class=\"keyword\">string</span></span><br><span class=\"line\">    i := strings.Index(s, sep)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &gt; <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result, s[:i])</span><br><span class=\"line\">        s = s[i+<span class=\"built_in\">len</span>(sep):]</span><br><span class=\"line\">        i = strings.Index(s, sep)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(result, s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>在当前目录下且一样的包名 goTest ，写一个简单的 go 测试函数，如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> goTest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"reflect\"</span></span><br><span class=\"line\">    <span class=\"string\">\"testing\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSplit</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    got := Split(<span class=\"string\">\"a/b/c\"</span>, <span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    want := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class=\"line\">        t.Fatalf(<span class=\"string\">\"expected: %v, got: %v\"</span>, want, got)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>测试函数必须以 Test 开头， 且必须携带一个 *testing.T 参数。 t *testing.T 提供改测试函数的打印、跳过、失败功能。</p>\n<h3 id=\"测试执行\">测试执行<a href=\"2019/07/28/Go_Testing#测试执行\"></a></h3>","link":"2019/07/28/Go_Testing","tags":["Go","测试理论"],"categories":["test"]},{"title":"MySQL 使用及调优","date":"2019-05-20T15:34:08.724Z","date_formatted":{"ll":"May 20, 2019","L":"05/20/2019","MM-DD":"05-20"},"excerpt":"<h2 id=\"数据库使用、调优\">数据库使用、调优<a href=\"2019/05/20/MySQL使用及调优#数据库使用、调优\"></a></h2><ol>\n<li><a href=\"2019/05/20/MySQL使用及调优#1\">检索数据 select</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#2\">排序数据 order by</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#3\">过滤数据 where</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#4\">数据过滤 where and / or / in / not in</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#5\">模糊查询 like</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#6\">正则匹配 regexp</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#7\">创建计算字段 concat / trim</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#8\">使用函数</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#9\">分组/过滤 group by / having</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#10\">使用子查询</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#11\">联结表 join</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#12\">组合查询 union</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#13\">插入数据 insert</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#14\">更新和删除数据 update/delete</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#15\">创建和操作表 create/alter/references</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#16\">使用视图 view</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#17\">存储过程/游标/触发器/事务处理</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#18\">全球化和本地化/安全管理/数据库维护</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#19\">改善性能</a></li>\n</ol>","link":"2019/05/20/MySQL使用及调优","tags":["MySQL"],"categories":["编程"]},{"title":"C++ 指针","date":"2019-05-12T22:50:41.401Z","date_formatted":{"ll":"May 13, 2019","L":"05/13/2019","MM-DD":"05-13"},"excerpt":"<h2 id=\"指针\">指针<a href=\"2019/05/13/指针_C++#指针\"></a></h2><p>指针是一个变量，其存储的是值的地址，而不是值本身。 值的地址，只需对变量应用地址运算符(&amp;)，即可得到其地址；例如home是一个变量，则&amp;home是它的地址。   *运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址存储的值。例如L: mainly是一个指针，则mainly是一个地址，*mainly表示存储在该地址处的值。</p>\n<h4 id=\"1-声明指针\">1.声明指针<a href=\"2019/05/13/指针_C++#1-声明指针\"></a></h4><p>要声明指向特定类型的指针，请使用下面的格式：<br><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeName * pointerName;  <span class=\"comment\">// 示例： double * pn;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指针声明的格式。传统上C程序员使用该格式：</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptr;  <span class=\"comment\">// 强调 *ptr 是一个int类型的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而C++大多数使用下述格式：</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* ptr;  <span class=\"comment\">// 强调 int* 是一种类型 -- 指向int的指针</span></span><br></pre></td></tr></table></div></figure></p>\n<p>其实，对于编译器来说空格所处位置没有区别，甚至可以不加空格，直接： int*ptr； 但是要知道的是，声明多个指针时，对每个指针变量名，都需要使用一个* 。</p>","link":"2019/05/13/指针_C++","tags":["C"],"categories":["编程"]},{"title":"设计模式","date":"2019-05-11T05:31:59.465Z","date_formatted":{"ll":"May 11, 2019","L":"05/11/2019","MM-DD":"05-11"},"excerpt":"","link":"2019/05/11/设计模式","tags":["Patterns"],"categories":["设计模式"]},{"title":"软件可测试性","date":"2019-05-11T03:28:42.636Z","date_formatted":{"ll":"May 11, 2019","L":"05/11/2019","MM-DD":"05-11"},"excerpt":"<p>分析软件的可测试性，旨在加快测试进度、提高测试效率等。</p>\n<p>软件的可测试性是指被测对象具有某些特征，如：<strong>可控制、可分解、稳定、易理解、可观察</strong>等。</p>\n<p>可测性设计时需要保证的是：</p>\n<ol>\n<li>不对软件本身的功能产生影响；</li>\n<li>不产生附加的测试。</li>\n</ol>\n<p><img src=\"/可测试性.jpg\" alt=\"可测试性\" class=\"article-img\"></p>","link":"2019/05/11/软件可测性","tags":["测试理论"],"categories":["test"]},{"title":"查找算法之二分查找","date":"2019-05-08T08:50:38.072Z","date_formatted":{"ll":"May 8, 2019","L":"05/08/2019","MM-DD":"05-08"},"excerpt":"<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>查找算法</th>\n<th>平均时间复杂度</th>\n<th>空间复杂度</th>\n<th>查找条件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>顺序查找</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>无序或有序</td>\n</tr>\n<tr>\n<td>二分查找(折半查找)</td>\n<td>O(log~2~n)</td>\n<td>O(1)</td>\n<td>有序</td>\n</tr>\n<tr>\n<td>插值查找</td>\n<td>O(log~2~(log~2~n))</td>\n<td>O(1)</td>\n<td>有序</td>\n</tr>\n<tr>\n<td>斐波那契查找</td>\n<td>O(log~2~n)</td>\n<td>O(1)</td>\n<td>有序</td>\n</tr>\n<tr>\n<td>哈希查找</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>无序或有序</td>\n</tr>\n</tbody>\n</table></div></div>","link":"2019/05/08/查找算法之二分查找","tags":["Python"],"categories":["算法"]},{"title":"复杂度分析","date":"2019-05-01T06:15:19.698Z","date_formatted":{"ll":"May 1, 2019","L":"05/01/2019","MM-DD":"05-01"},"excerpt":"<p>如何分析、统计算法的执行效率(执行时间)和资源消耗(占用空间)？<br></p>\n<p>数据结构和算法 解决的问题是”如何让计算机更快时间、更省空间”， 所以需要从执行时间、占用空间两个维度评估算法性能。复杂度分析 是时间复杂度和空间复杂度的统称，描述的是算法执行时间(占用空间)与数据规模的增长关系。和 性能测试 相比。复杂度分析不依赖执行环境、成本低、效率高、指导性强<br>        <strong>[复杂度分析]</strong> 一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法<br>        <strong>[性能的基准测试]</strong> 事后统计法：跑代码，通过统计、监控，得到算法执行的时间和占用的内存大小。得到的实验结果，受环境、数据规模大小因素影响较大<br></p>","link":"2019/05/01/复杂度分析","categories":["算法"]}]}