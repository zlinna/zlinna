{"per_page":10,"total":2,"current":1,"data":[{"title":"2020","date":"2019-12-28T05:08:38.827Z","date_formatted":{"ll":"Dec 28, 2019","L":"12/28/2019","MM-DD":"12-28"},"excerpt":"<p>技术栈扩充</p>\n<ol>\n<li>Robot Framework training - expand</li>\n<li>postman training</li>\n<li>fiddler、wireshark training</li>\n<li>go、react training</li>\n<li>python + redis training</li>\n<li>python 仿 tf 实现 restful 接口测试框架 demo</li>\n<li>MongoDB</li></ol>","link":"2019/12/28/2020","tags":["zlinna"]},{"title":"测试用例分类","date":"2019-12-14T09:33:04.162Z","date_formatted":{"ll":"Dec 14, 2019","L":"12/14/2019","MM-DD":"12-14"},"excerpt":"","link":"2019/12/14/测试用例分类","tags":["Test","测试理论"]},{"title":"Go 的位运算","date":"2019-09-07T08:53:26.329Z","date_formatted":{"ll":"Sep 7, 2019","L":"09/07/2019","MM-DD":"09-07"},"excerpt":"<h2 id=\"Go-的位运算\">Go 的位运算<a href=\"2019/09/07/go的位运算#Go-的位运算\"></a></h2><p>在 Go 语言中支持以下几种操作位的方式：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 在 Go 语言中支持以下几种操作位的方式：</span></span><br><span class=\"line\"><span class=\"comment\">        &amp;   // 位与：仅当 a 和 b 都为 1 时，操作 a&amp;b 返回 1，否则返回 0。</span></span><br><span class=\"line\"><span class=\"comment\">        |   // 位或：仅当 a 和 b 都为 0 时，操作 a|b 返回 0，否则返回 1。</span></span><br><span class=\"line\"><span class=\"comment\">        ^   // 异或：仅当 a!=b 时，操作 a^b 返回 1，否则返回 0。</span></span><br><span class=\"line\"><span class=\"comment\">        &amp;^  // 位与非：仅当 a=1, b=0 时，操作 a&amp;^b 返回 1，否则返回 0。</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;&lt;  // 左移：a &lt;&lt; n，将 a 中的所有位向左偏移 n 次, 右边用0补齐</span></span><br><span class=\"line\"><span class=\"comment\">        &gt;&gt;  // 右移：a &gt;&gt; n; 将 a 中的所有位向右偏移 n 次, 左边用0补齐</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></div></figure>\n<p>详情见以下示例：<br></p>","link":"2019/09/07/go的位运算","tags":["Go"]},{"title":"wangwg","date":"2019-09-04T23:50:37.552Z","date_formatted":{"ll":"Sep 5, 2019","L":"09/05/2019","MM-DD":"09-05"},"excerpt":"","link":"2019/09/05/wangwg","tags":["zlinna"]},{"title":"Ginkgo 测试框架使用入门","date":"2019-08-28T14:06:28.779Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"excerpt":"<h1 id=\"Ginkgo-介绍\">Ginkgo 介绍<a href=\"2019/08/28/Ginkgo测试框架#Ginkgo-介绍\"></a></h1><p>Ginkgo是一个BDD风格的Go测试框架，旨在帮助您有效地编写富有表现力的综合测试。</p>\n<h2 id=\"安装及依赖\">安装及依赖<a href=\"2019/08/28/Ginkgo测试框架#安装及依赖\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go get github.com/onsi/ginkgo/ginkgo</span><br><span class=\"line\">$ go get github.com/onsi/gomega/...</span><br></pre></td></tr></table></div></figure>\n<p>在 $GOPATH 下使用上述命令安装 ginkgo 及匹配器 gomega。使用过程中遇到的问题：<br><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ginkgo <span class=\"comment\">#or go test</span></span><br><span class=\"line\">Failed to compile 0344-reverse-string:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leetcode/case/0344-reverse-string</span></span><br><span class=\"line\">package leetcode/<span class=\"keyword\">case</span>/0344-reverse-string_test</span><br><span class=\"line\">        imports github.com/onsi/gomega</span><br><span class=\"line\">        imports github.com/onsi/gomega/matchers</span><br><span class=\"line\">        imports golang.org/x/net/html/charset</span><br><span class=\"line\">        imports golang.org/x/text/encoding: cannot find package <span class=\"string\">\"golang.org/x/text/encoding\"</span> <span class=\"keyword\">in</span> any of:</span><br><span class=\"line\">        /usr/<span class=\"built_in\">local</span>/go/src/golang.org/x/text/encoding (from <span class=\"variable\">$GOROOT</span>)</span><br><span class=\"line\">        /Users/night/go_learn/src/golang.org/x/text/encoding (from <span class=\"variable\">$GOPATH</span>)</span><br></pre></td></tr></table></div></figure></p>\n<p>问题为 text/encoding 包未找到，解决方案如下：<br><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> <span class=\"variable\">$GOPATH</span>/src</span><br><span class=\"line\">$ mkdir golang.org/x/</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> golang.org/x</span><br><span class=\"line\">$  git <span class=\"built_in\">clone</span> https://github.com/golang/text.git text</span><br></pre></td></tr></table></div></figure></p>","link":"2019/08/28/Ginkgo测试框架","tags":["Go","Test","测试实践","测试框架"]},{"title":"测试角度学习 groupcache","date":"2019-08-21T13:09:32.578Z","date_formatted":{"ll":"Aug 21, 2019","L":"08/21/2019","MM-DD":"08-21"},"excerpt":"<h1 id=\"groupcache-介绍\">groupcache 介绍<a href=\"2019/08/21/测试角度学习groupcache#groupcache-介绍\"></a></h1><p>“groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.”。作者如是介绍该项目，翻译后的意思为：groupcache 是一个缓存和缓存填充库，在许多情况下用作 memcached 的替代品。</p>\n<p>It is paused now..<br></p>","link":"2019/08/21/测试角度学习groupcache","tags":["Go","Test","测试实践"]},{"title":"测试角度学习 cache2go","date":"2019-08-20T13:44:35.633Z","date_formatted":{"ll":"Aug 20, 2019","L":"08/20/2019","MM-DD":"08-20"},"excerpt":"<h1 id=\"cache2go-介绍\">cache2go 介绍<a href=\"2019/08/20/测试角度学习cache2go#cache2go-介绍\"></a></h1><p>“Concurrency-safe golang caching library with expiration capabilities.”。作者如是介绍该项目，翻译后的意思为：存在心跳机制且并发安全的go语言缓存库。</p>\n<h3 id=\"tips\">tips<a href=\"2019/08/20/测试角度学习cache2go#tips\"></a></h3><p>测试行为，而非实施。 “The public API of a package declare this is what(行为) I do, not this is <del>how(实施)</del> I do it.”</p>\n<h3 id=\"测试角度学习-cache2go\">测试角度学习 cache2go<a href=\"2019/08/20/测试角度学习cache2go#测试角度学习-cache2go\"></a></h3><p>我们知道心跳机制、并发安全是 cache2go 的两大特点，那么肯定是测试的重点了。 【Cachetable 简称 table，cacheitem 简称 item】</p>\n<p>首先查看 cache_test.go ，可以获得以下信息：<br></p>","link":"2019/08/20/测试角度学习cache2go","tags":["Go","Test","测试实践"]},{"title":"Go Testing;How,What,Why","date":"2019-07-28T02:43:54.507Z","date_formatted":{"ll":"Jul 28, 2019","L":"07/28/2019","MM-DD":"07-28"},"excerpt":"<h2 id=\"前言\">前言<a href=\"2019/07/28/Go_Testing#前言\"></a></h2><p>关于 Go 测试，我们应该知道测试方式（或者说测试手段）、测试对象及测试原因。</p>\n<h2 id=\"How-测试方式\">How 测试方式<a href=\"2019/07/28/Go_Testing#How-测试方式\"></a></h2><h3 id=\"测试实现\">测试实现<a href=\"2019/07/28/Go_Testing#测试实现\"></a></h3><p>举个例子。针对字符串分割函数（如下），实现单元测试。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> goTest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"strings\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Split slices s into all substrings separated by sep and</span></span><br><span class=\"line\"><span class=\"comment\">// returns a slice of the substrings between those separators.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Split</span><span class=\"params\">(s, sep <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result []<span class=\"keyword\">string</span></span><br><span class=\"line\">    i := strings.Index(s, sep)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &gt; <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result, s[:i])</span><br><span class=\"line\">        s = s[i+<span class=\"built_in\">len</span>(sep):]</span><br><span class=\"line\">        i = strings.Index(s, sep)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">append</span>(result, s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>在当前目录下且一样的包名 goTest ，写一个简单的 go 测试函数，如下：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> goTest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"reflect\"</span></span><br><span class=\"line\">    <span class=\"string\">\"testing\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestSplit</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    got := Split(<span class=\"string\">\"a/b/c\"</span>, <span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    want := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class=\"line\">        t.Fatalf(<span class=\"string\">\"expected: %v, got: %v\"</span>, want, got)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>测试函数必须以 Test 开头， 且必须携带一个 *testing.T 参数。 t *testing.T 提供改测试函数的打印、跳过、失败功能。</p>\n<h3 id=\"测试执行\">测试执行<a href=\"2019/07/28/Go_Testing#测试执行\"></a></h3>","link":"2019/07/28/Go_Testing","tags":["Go","Test","测试理论"]},{"title":"MySQL 使用及调优","date":"2019-05-20T15:34:08.724Z","date_formatted":{"ll":"May 20, 2019","L":"05/20/2019","MM-DD":"05-20"},"excerpt":"<h2 id=\"数据库使用、调优\">数据库使用、调优<a href=\"2019/05/20/MySQL使用及调优#数据库使用、调优\"></a></h2><ol>\n<li><a href=\"2019/05/20/MySQL使用及调优#1\">检索数据 select</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#2\">排序数据 order by</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#3\">过滤数据 where</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#4\">数据过滤 where and / or / in / not in</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#5\">模糊查询 like</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#6\">正则匹配 regexp</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#7\">创建计算字段 concat / trim</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#8\">使用函数</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#9\">分组/过滤 group by / having</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#10\">使用子查询</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#11\">联结表 join</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#12\">组合查询 union</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#13\">插入数据 insert</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#14\">更新和删除数据 update/delete</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#15\">创建和操作表 create/alter/references</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#16\">使用视图 view</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#17\">存储过程/游标/触发器/事务处理</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#18\">全球化和本地化/安全管理/数据库维护</a></li>\n<li><a href=\"2019/05/20/MySQL使用及调优#19\">改善性能</a></li>\n</ol>","link":"2019/05/20/MySQL使用及调优","tags":["MySQL"]},{"title":"C++ 指针","date":"2019-05-12T22:50:41.401Z","date_formatted":{"ll":"May 13, 2019","L":"05/13/2019","MM-DD":"05-13"},"excerpt":"<h2 id=\"指针\">指针<a href=\"2019/05/13/指针_C++#指针\"></a></h2><p>指针是一个变量，其存储的是值的地址，而不是值本身。 值的地址，只需对变量应用地址运算符(&amp;)，即可得到其地址；例如home是一个变量，则&amp;home是它的地址。   *运算符被称为间接值(indirect value)或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址存储的值。例如L: mainly是一个指针，则mainly是一个地址，*mainly表示存储在该地址处的值。</p>\n<h4 id=\"1-声明指针\">1.声明指针<a href=\"2019/05/13/指针_C++#1-声明指针\"></a></h4><p>要声明指向特定类型的指针，请使用下面的格式：<br><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeName * pointerName;  <span class=\"comment\">// 示例： double * pn;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指针声明的格式。传统上C程序员使用该格式：</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptr;  <span class=\"comment\">// 强调 *ptr 是一个int类型的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而C++大多数使用下述格式：</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* ptr;  <span class=\"comment\">// 强调 int* 是一种类型 -- 指向int的指针</span></span><br></pre></td></tr></table></div></figure></p>\n<p>其实，对于编译器来说空格所处位置没有区别，甚至可以不加空格，直接： int*ptr； 但是要知道的是，声明多个指针时，对每个指针变量名，都需要使用一个* 。</p>","link":"2019/05/13/指针_C++","tags":["C"]}]}