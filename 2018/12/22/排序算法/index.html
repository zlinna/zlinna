<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>I'm here.</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">zlin</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/gallery/" target="_self">GALLERY</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">排序算法</h1><div class="post-info">Dec 22nd 2018</div><div class="post-entry"><h1><span id="排序">排序</span></h1><table>
<thead>
<tr>
<th style="text-align:left">排序算法</th>
<th style="text-align:left">平均时间复杂度</th>
<th style="text-align:left">最差时间复杂度</th>
<th style="text-align:left">空间复杂度</th>
<th style="text-align:left">数据对象稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">数组不稳定、链表稳定</td>
</tr>
<tr>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">O(n*log~2~n)</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(log~2~n)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">O(n*log~2~n)</td>
<td style="text-align:left">O(n^2^)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">O(n*log~2~n)</td>
<td style="text-align:left">O(n*log~2~n)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">稳定</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3><span id="冒泡排序">冒泡排序</span></h3><h5><span id="python实现">Python实现</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序:（bubble sort）是一种简单的排序算法。</span></span><br><span class="line"><span class="string">    它重复地遍历要排列的序列，一词比较2个元素，如果它们的顺序错误就交换。遍历数列的</span></span><br><span class="line"><span class="string">工作是重复地进行直到没有再需要交换。即排序完成。步骤如下:</span></span><br><span class="line"><span class="string">    1. 比较相邻的元素，如果第二个比第一个大（升序），就交换；</span></span><br><span class="line"><span class="string">    2. 对每一对相邻元素作同样的工作，从开始的一对到最后的一对，找出最大的元素；</span></span><br><span class="line"><span class="string">    3. 针对所有的元素，重复以上步骤，除了最后一个；</span></span><br><span class="line"><span class="string">    4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n)  [表示遍历一次发现没有任何可以交换的元素，排序结束]</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">    <span class="comment">#外层确定次数</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span> -j):</span><br><span class="line">        <span class="comment">#for i in range(0, n-1):</span></span><br><span class="line">        <span class="comment">#内存确定一个数（最大或最小）</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="comment">#[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> == count:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    bubble_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure>
<h5><span id="cc实现">C/C++实现</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3><span id="插入排序">插入排序</span></h3><h5><span id="python实现">Python实现</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序（insertion sort）是一种简单直观的排序算法。工作原理：</span></span><br><span class="line"><span class="string">    通过构建有序序列，对于未排序数据，在已排序序列中向前扫描，找到相应位置并插入。</span></span><br><span class="line"><span class="string">    插入排序实现上，在从后向前扫描中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n) (升序，序列已处于升序状态)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># alist = [93,      54, 77, 31, 44, 55, 226]</span></span><br><span class="line"><span class="comment"># alist = [54, 93,      77, 31, 44, 55, 226]</span></span><br><span class="line"><span class="comment"># alist = [54, 77, 93,      31, 44, 55, 226]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 从右边的无序序列中取出多少个元素执行这样的过程</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># i = [1, 2, 3, ...,n-1]</span></span><br><span class="line">        <span class="comment"># i 代表内层循环起始值</span></span><br><span class="line">        i = j</span><br><span class="line">        <span class="comment"># 执行从右边的无序序列中取出第一个元素，即 i 位置的元素，然后插入到前面的正确位置中</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> alist[i] &lt; alist[i<span class="number">-1</span>]:</span><br><span class="line">                alist[i<span class="number">-1</span>], alist[i] = alist[i], alist[i<span class="number">-1</span>]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># i=j j-1 j-2 ... 1   # range(j, 0, -1)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def insert_sort(alist):</span></span><br><span class="line"><span class="comment">#     for i in range(1, len(alist)):</span></span><br><span class="line"><span class="comment">#         for j in range(i, 0, -1):</span></span><br><span class="line"><span class="comment">#             if alist[i] &lt; alist[i-1]:</span></span><br><span class="line"><span class="comment">#                 alist[i], alist[i-1] = alist[i-1], alist[i]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    select_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure>
<h5><span id="cc实现">C/C++实现</span></h5><h3><span id="选择排序">选择排序</span></h3><h5><span id="python实现">Python实现</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序 (selection sort)是一种简单直观的排序算法。工作原理如下：</span></span><br><span class="line"><span class="string">    1. 在未排序序列中找到最小（大）元素存放到序列的起始位置；</span></span><br><span class="line"><span class="string">    2. 从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</span></span><br><span class="line"><span class="string">    3. 依次类推，直到排序完成。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># alist = [17, 20,     93, 54, 43, 67, 224, 23]</span></span><br><span class="line"><span class="comment">#          0   1       2   3   4   5   6    7</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># j = [0, 1, 2, 3..., n-2 ]</span></span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    select_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure>
<h5><span id="cc实现">C/C++实现</span></h5><h3><span id="快速排序">快速排序</span></h3><h5><span id="python实现">Python实现</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序（Quicksort）是一种比较排序，这意味着它可以对任何类型的项目进行</span></span><br><span class="line"><span class="string">排序.稳定的排序，这意味着相同的排序项目的相对顺序不会被保留，快速排序可以在数组</span></span><br><span class="line"><span class="string">上就地操作，需要少量额外的内存来执行排序。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data_list = [54,26,93,17,77,31,44,55,20]</span></span><br><span class="line"><span class="comment">#               |  |                    |</span></span><br><span class="line"><span class="comment">#      pivotvalue leftmark -&gt;       &lt;- rightmark</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    temp = data_list[leftmark]</span></span><br><span class="line"><span class="comment">#    data_list[leftmark] = data_list[rightmark]</span></span><br><span class="line"><span class="comment">#    data_list[rightmark] = temp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(data_list)</span>:</span></span><br><span class="line">    quickSortHlp(data_list,<span class="number">0</span>,len(data_list)<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSortHlp</span><span class="params">(data_list,first,last)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> first &lt; last:</span><br><span class="line">        splitpoint = partition(data_list,first,last)</span><br><span class="line">        quickSortHlp(data_list,first,splitpoint<span class="number">-1</span>)</span><br><span class="line">        quickSortHlp(data_list,splitpoint+<span class="number">1</span>,last)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(data_list,first,last)</span>:</span></span><br><span class="line">    pivotvalue = data_list[first]</span><br><span class="line">    leftmark = first+<span class="number">1</span></span><br><span class="line">    rightmark = last</span><br><span class="line">    done = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">       <span class="keyword">while</span> leftmark &lt;= rightmark <span class="keyword">and</span> data_list[leftmark] &lt;= pivotvalue:</span><br><span class="line">           leftmark = leftmark + <span class="number">1</span></span><br><span class="line">       <span class="keyword">while</span> data_list[rightmark] &gt;= pivotvalue <span class="keyword">and</span> rightmark &gt;= leftmark:</span><br><span class="line">           rightmark = rightmark <span class="number">-1</span></span><br><span class="line">       <span class="keyword">if</span> rightmark &lt; leftmark:</span><br><span class="line">           done = <span class="keyword">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           temp = data_list[leftmark]</span><br><span class="line">           data_list[leftmark] = data_list[rightmark]</span><br><span class="line">           data_list[rightmark] = temp</span><br><span class="line">    <span class="comment"># print(data_list,data_list[rightmark],rightmark)</span></span><br><span class="line">    temp = data_list[first]</span><br><span class="line">    data_list[first] = data_list[rightmark]</span><br><span class="line">    data_list[rightmark] = temp</span><br><span class="line">    <span class="keyword">return</span> rightmark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    quickSort(data_list)</span><br><span class="line">    print(data_list)</span><br></pre></td></tr></table></figure>
<h5><span id="cc实现">C/C++实现</span></h5><h3><span id="希尔排序">希尔排序</span></h3><h5><span id="python实现">Python实现</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序（shell sort）是插入排序的一种，也称缩小增量排序。是直接插入排序算法</span></span><br><span class="line"><span class="string">的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序</span></span><br><span class="line"><span class="string">算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被</span></span><br><span class="line"><span class="string">分成一组，算法终止。</span></span><br><span class="line"><span class="string">    基本思想：</span></span><br><span class="line"><span class="string">    将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长，</span></span><br><span class="line"><span class="string">列数更少）来进行。最后整个表就只有1列了。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #最优时间复杂度： 根据步长序列的不同而不同</span></span><br><span class="line"><span class="string">    #最坏时间复杂度： O(n^2)</span></span><br><span class="line"><span class="string">    #稳定性：不稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># i = gap</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 插入算法，与普通的插入算法区别就是gap步长</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># i = [gap, gap+1, ..., n-1]</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i-gap]:</span><br><span class="line">                    alist[i], alist[i-gap] = alist[i-gap], alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    alist = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">    shell_sort(alist)</span><br><span class="line">    print(alist)</span><br></pre></td></tr></table></figure>
<h5><span id="cc实现">C/C++实现</span></h5><h3><span id="归并排序">归并排序</span></h3><h5><span id="python实现">Python实现</span></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   归并排序（）采用分治法的一个典型应用。</span></span><br><span class="line"><span class="string">   归并排序的思想就是先递归分解数组，再合并数组。</span></span><br><span class="line"><span class="string">   将数组分解最小之后，然后合并2个有序数组，基本思路就是比较两个数组的最前面的数，</span></span><br><span class="line"><span class="string">谁小就先取谁，取了之后相应的指针往后移一位。然后再比较，直至一个数组为空，最后把另</span></span><br><span class="line"><span class="string">一个数组的剩余部分复制过来即可。</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  #最优时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">  #最坏时间复杂度： O(n log n)</span></span><br><span class="line"><span class="string">  #稳定性：稳定</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    <span class="comment"># left 采用归并排序后有序的新的列表</span></span><br><span class="line">    left_list = merge_sort(alist[:mid])</span><br><span class="line">    <span class="comment"># right 采用归并排序后有序的新的列表</span></span><br><span class="line">    right_list = merge_sort(alist[mid:])</span><br><span class="line">    <span class="comment"># 将两个有序子列表合并为一个新列表</span></span><br><span class="line">    <span class="comment"># merge(left, right)</span></span><br><span class="line">    left_pointer, right_pointer = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left_pointer &lt; len(left_list) <span class="keyword">and</span> right_pointer &lt; len(right_list):</span><br><span class="line">        <span class="keyword">if</span> left_list[left_pointer] &lt;= right_list[right_pointer]:</span><br><span class="line">            result.append(left_list[left_pointer])</span><br><span class="line">            left_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_list[right_pointer])</span><br><span class="line">            right_pointer += <span class="number">1</span></span><br><span class="line">    result += left_list[left_pointer:]</span><br><span class="line">    result += right_list[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data_list = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">    sorted = merge_sort(data_list)</span><br><span class="line">    print(sorted)</span><br></pre></td></tr></table></figure>
<h5><span id="cc实现">C/C++实现</span></h5></div><div class="post-tags-box"><a class="tag-link" href="/tags/C/">C++</a>, <a class="tag-link" href="/tags/Python/">Python</a>, <a class="tag-link" href="/tags/算法/">算法</a></div></article></div><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2019/05/01/复杂度分析/" class="prev-post">复杂度分析</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2018/12/09/zxl01/" class="next-post">To You</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;zlin&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>